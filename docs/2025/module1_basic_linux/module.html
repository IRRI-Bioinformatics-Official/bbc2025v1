<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">

<title>Basic Linux Course</title>
<style>
body {
	font-family: Arial, sans-serif;
	margin: 0;
	padding: 0;
	line-height: 1.6;
	font-size: 15px;
	display: flex;
	margin-bottom: 100px;
}

html, body {
	height: 100%;
	overflow: auto;
	overscroll-behavior: contain;
}

/* Floating Table of Contents */
#toc {
	position: fixed;
	top: 0px;
	left: 20px;
	width: 220px;
	background-color: #f8f9fa;
	padding: 1rem;
	border-radius: 8px;
	box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
	z-index: 1000;
	max-height: 100vh; /* Restrict height to the viewport */
	overflow-y: auto;  /*Enable vertical scroll */
}

#toc h2 {
	font-size: 1.2rem;
	margin-bottom: 1rem;
}

#toc ul {
	list-style-type: none;
	font-size: .9rem;
	padding: 0;
}

#toc ul li {
	margin: 0.5rem 0;
}

#toc ul li a {
	text-decoration: none;
	color: #007bff;
}

#toc ul li a:hover {
	text-decoration: underline;
}
/* Main content styling */
main {
	margin-left: 260px; /* Adjusted for TOC width */
	padding: 2rem;
	flex-grow: 1;
}

h1, h2 {
	color: #2c3e50;
}

section {
	margin-bottom: 2rem;
	max-width: 800px;
	padding: 20px;
	background-color: white;
	border-radius: 8px;
	box-shadow: 0 4px 8px rgba(0, 0, 0, 0.1);
}

pre, code {
	background-color: #ededed;
	color: #312f2f;
	padding: 5px 10px;
	border-radius: 4px;
	font-size: .9em;
	font-family: Consolas, monospace;
	overflow-x: auto;
}

code {
	font-size: 1em;
	background-color: #ededed;
	padding: 2px 5px;
	border-radius: 3px;
}

.codeCopy {
	width: 100%;
	display: block;
}

  .tip {
      background: #dff0d8;
      border-left: 5px solid #3c763d;
      padding: 10px;
      margin: 10px 0;
    }

ul {
	list-style-type: none;
	padding-left: 20px;
}

ul li {
	margin-bottom: 10px;
}

ol {
	padding-left: 20px;
}

li {
	margin-bottom: 10px;
}

strong {
	color: #2c3e50;
}

/* Responsive adjustments */
@media ( max-width : 768px) {
	body {
		flex-direction: column;
	}
	#toc {
		position: static;
		width: auto;
		box-shadow: none;
		margin: 1rem;
		overflow-y: unset;
	}
	main {
		margin-left: 0;
		padding: 1rem;
	}
}

@media ( max-width : 480px) {
	#toc h2 {
		font-size: 1rem;
	}
	#toc ul li {
		font-size: 0.85rem;
	}
	section {
		padding: 1rem;
	}
	pre, code {
		font-size: 0.85em;
	}
}

.output-box {
	border: 1px solid #ccc;
	padding: 10px;
	margin: 10px;
	width: 300px;
	overflow-x: auto;
}

#copy-btn {
	margin-top: 10px;
	cursor: pointer;
	position: absolute;
	top: 10px; /* Position the button at the top */
	right: 10px; /* Position the button at the right */
	border: 0px;
	background: #369136;
	padding: 5px;
	border-radius: 5px;
	color: white;
}

#copy-btn:hover {
	background-color: #45a049;
}

.code_div {
	width: 100%;
	margin-top: 10px;
	margin-bottom: 10px;
	padding: 5px;
}

.codeStyle {
	width: 100%;
	display: block;
}

.aligned-list li {
	list-style: none;
	margin: 4px 0;
}

.aligned-list a {
	display: inline-block;
	min-width: 240px; /* adjust as needed */
	padding-left: 1em;
	text-indent: -1em;
	white-space: nowrap;
}
</style>
<script>
  document.addEventListener("DOMContentLoaded", function () {
    const toc = document.getElementById("toc");
    const toggleBtn = document.getElementById("toggleToc");

    function checkScreenWidth() {
      if (window.innerWidth <= 768) {
        toggleBtn.style.display = 'block';
        toc.style.display = 'none';
      } else {
        toggleBtn.style.display = 'none';
        toc.style.display = 'block';
      }
    }

    toggleBtn.addEventListener("click", () => {
      toc.style.display = (toc.style.display === 'none') ? 'block' : 'none';
    });

    window.addEventListener("resize", checkScreenWidth);
    checkScreenWidth();
    
    const copyButtons = document.querySelectorAll('.copy-btn');
    
    copyButtons.forEach(button => {
        button.addEventListener("click", function() {
            // Find the associated command text (inside the <code> tag)
            const commandText = button.previousElementSibling.innerText;

            // Create a temporary input to copy the command text
            const tempInput = document.createElement("input");
            tempInput.value = commandText;
            document.body.appendChild(tempInput);

            // Select the text and copy it
            tempInput.select();
            document.execCommand("copy");

            // Remove the temporary input
            document.body.removeChild(tempInput);

            button.textContent = "Copied";
        });
    });
  });
</script>



</head>
<body>
	<script>
    document.addEventListener("DOMContentLoaded", function () {
      const tocLinks = document.querySelectorAll('#toc a[data-target]');
      tocLinks.forEach(link => {
        link.addEventListener('click', function (e) {
          e.preventDefault();
          const targetId = this.getAttribute('data-target');
          const targetElement = document.getElementById(targetId);
          if (targetElement) {
            targetElement.scrollIntoView({ behavior: 'smooth', block: 'start' });
          }
        });
      });
    });
  </script>
	<!-- Floating Table of Contents -->
	<div id="toc">
		<h2>Table of Contents:</h2>
		<ul class="aligned-list">
			<li><details>
					<summary>
						<strong>Day 1</strong>
					</summary>
					<li><a href="#" data-target="overview">i. Overview</a></li>
					<li><a href="#" data-target="os">I. Operating Systems</a></li>
					<li><a href="#" data-target="why-linux">II. Linux for
							Bioinformatics</a></li>
					<li><a href="#" data-target="intro-linux-commands">III.
							Linux Commands</a></li>
					<li><a href="#" data-target="filesystem-structure">IV.
							Filesystem Structure and Layout</a></li>
					<li><a href="#" data-target="filesystem">V. Filesystem
							Navigation</a></li>
					<li><a href="#" data-target="filemanagement">VI. File
							Management</a></li>
					<li><a href="#" data-target="compressed">VII. Handling Compressed Files</a></li>
					<li><a href="#" data-target="viewing">VIII. Viewing Files</a></li>
					<li><a href="cheatsheet_day1.html" target="_blank">Cheat Sheet</a></li>
					
							
					
				</details></li>
			<li><details>
					<summary>
						<strong>Day 2</strong>
					</summary>
					<li><a href="#" data-target="hard-soft">VI. Hard and
							Soft Links</a></li>
					<li><a href="#" data-target="bioinformatics-file-formats">IX.
							Bioinformatics File Formats</a></li>
					<li><a href="#" data-target="pattern-matching">X. Pattern
							Matching in Bash</a></li>
					<li><a href="#" data-target="text-processing-tools">XI.
							Text Processing Tools</a></li>
					<li><a href="cheatsheet_day2.html" target="_blank">Cheat Sheet</a></li>
					
				</details></li>
			<li><details>
					<summary>
						<strong>Day 3</strong>
					</summary>
					<li><a href="#" data-target="io-redirection">XIII. I/O
							Redirection</a></li>
					<li><a href="#" data-target="bash-bioinformatics">XII.
							Bash Manipulation And Scripting</a></li>
					<li><a href="#" data-target="linux-process-control">XIV.
							Process Control</a></li>
					<li><a href="#" data-target="linux-job-control">XIV. Job
							Control</a></li>
					<li><a href="#" data-target="shell-expansion">XV. Shell
							Expansion</a></li>
					
					<li><a href="#" data-target="environment-variables">XVII.
							Environment Variable</a></li>
					<li><a href="#" data-target="bashrc-bash_profile">XVIII.
							Shell Configuration Files</a></li>
					</details></li>
		</ul>
	</div>


	<!-- Main Content -->
	<main style="margin-bottom: 100px; margin-top: 20px;">
		<button id="toggleToc" style="display: none;">‚ò∞ Table of
			Contents</button>

		<section id="overview">
			<h2>üß≠ Training Overview: Linux Basics, Filesystem, and Shell
				Navigation</h2>

			<h3>üéØ Topic</h3>
			<p>Linux Basics, Filesystem, and Shell Navigation</p>

			<h3>üë• Target Audience</h3>
			<p>Beginners in bioinformatics ‚Äî no prior Linux experience
				required.</p>

			<h3>üèÅ Goal</h3>
			<p>Help participants become comfortable using the Linux terminal
				and executing essential file and folder commands commonly used in
				bioinformatics workflows.</p>
		</section>

		<section id="os">
			<h2>What is an Operating System?</h2>
			<p>
				An <strong>Operating System (OS)</strong> is the main software that
				runs your computer or phone. It controls everything ‚Äî apps, files,
				memory, and devices like your mouse or keyboard.
			</p>

			<h3>üß© What Does It Do?</h3>
			<ul>
				<li><strong>Runs Programs</strong><br> Lets you open and
					use apps like browsers, games, or Word.</li>
				<li><strong>Manages Memory</strong><br> Shares the
					computer‚Äôs memory (RAM) between programs so they don‚Äôt crash.</li>
				<li><strong>Stores Files</strong><br> Helps you save,
					open, and organize files in folders.</li>
				<li><strong>Controls Devices</strong><br> Makes the
					keyboard, mouse, speakers, and printer work.</li>
			</ul>
			<h2>Understanding Operating Systems for Bioinformatics</h2>
			<p>
				When working with bioinformatics tools, it's essential to understand
				the differences between operating systems (OS) like <strong>Windows</strong>,
				<strong>Linux</strong>, and <strong>macOS</strong>, as well as how
				to bridge the gap between them using tools like <strong>WSL
					(Windows Subsystem for Linux)</strong>.
			</p>

			<h3>1. Windows vs. Linux vs. macOS</h3>
			<ul>
				<li><strong>Windows</strong> is a popular OS for general use
					and is often used in corporate environments. While it has GUI-based
					tools, it can be limiting when working with command-line-heavy
					bioinformatics workflows. Many bioinformatics tools are not
					natively supported on Windows, requiring workarounds like WSL or
					virtual machines.</li>
				<li><strong>Linux</strong> is the preferred OS for
					bioinformatics because it offers superior performance, stability,
					and extensive command-line tools designed specifically for
					computational tasks and data analysis. Most bioinformatics software
					is optimized for Linux.</li>
				<li><strong>macOS</strong> is similar to Linux in terms of
					underlying architecture (both are Unix-based), so many
					bioinformatics tools that run on Linux can also run on macOS. It's
					often preferred by researchers who need a balance of ease of use
					(macOS GUI) and command-line functionality. It offers strong
					support for development environments and bioinformatics software,
					though some specialized Linux tools might require additional setup.</li>
			</ul>

			<h3>2. Windows Subsystem for Linux (WSL)</h3>
			<ul>
				<li><strong>WSL</strong> allows Windows users to run a Linux
					environment directly on top of Windows without the need for
					dual-booting or using virtual machines.</li>
				<li>WSL provides a full Linux kernel, enabling users to install
					and run popular bioinformatics tools that are typically only
					available on Linux.</li>
				<li><strong>Advantages of WSL:</strong></li>
				<ul>
					<li>Easy access to both Windows and Linux tools in one
						environment.</li>
					<li>Ideal for Windows users who need to run Linux tools
						without switching OS.</li>
					<li>Access to the Linux file system and native Linux utilities
						directly from Windows.</li>
				</ul>
				<li><strong>Limitations of WSL:</strong></li>
				<ul>
					<li>Some high-performance tools might not run as efficiently
						as on a full Linux system.</li>
					<li>While WSL 2 supports a full Linux kernel, it still
						operates within Windows, which could affect performance with very
						large datasets or computationally intensive tasks.</li>
				</ul>
			</ul>

			<h3>3. Choosing the Right OS for Your Work</h3>
			<ul>
				<li><strong>Linux</strong> is the best option for
					bioinformatics work, as it provides the best performance,
					efficiency, and native support for bioinformatics tools.</li>
				<li><strong>macOS</strong> is a good alternative if you need
					the Unix environment but prefer a more user-friendly GUI. It‚Äôs
					compatible with most bioinformatics tools and is widely used by
					researchers who prefer working with a Mac.</li>
				<li><strong>Windows</strong> is less ideal for bioinformatics
					but can be used effectively with tools like WSL to run Linux-based
					tools without switching OSs.</li>
				<li>If you‚Äôre a Windows user and need Linux tools, <strong>WSL</strong>
					is a great option to get the Linux environment without leaving
					Windows.
				</li>
				<li>For macOS users, using a native Unix-based environment
					makes it easy to run bioinformatics tools, but certain specialized
					Linux tools might require additional setup or a virtual machine.</li>
			</ul>
		</section>

		<section id="why-linux">
			<h2>Why Linux is Important in Bioinformatics</h2>
			<ul>
				<li><strong>Most Bioinformatics Tools Are Built for
						Linux:</strong> Many tools used in bioinformatics, like those for gene
					analysis and sequencing, work best on Linux systems.</li>
				<li><strong>Free and Open Source:</strong> Linux is free to
					use, and bioinformatics software is often open-source, meaning
					anyone can use, modify, and share it.</li>
				<li><strong>Handles Large Data Efficiently:</strong>
					Bioinformatics involves working with huge data files (like genome
					data). Linux is good at managing and processing large amounts of
					data quickly.</li>
				<li><strong>Works Well with High-Performance
						Computers:</strong> Many research labs use powerful Linux-based computers
					(called clusters) to analyze data faster.</li>
				<li><strong>Tons of Useful Tools:</strong> Linux has many
					built-in tools that make it easy to work with large data files,
					such as sorting, searching, and filtering information.</li>
			</ul>
		</section>
		<!-- 
		<section id="linux-better">
			<h2>Why Linux is Better Than GUI (Graphical User Interface)
				Tools</h2>
			<ul>
				<li><strong>Faster and More Efficient:</strong> Linux tools are
					lightweight, meaning they use less memory and run faster compared
					to GUI-based tools.</li>
				<li><strong>Automation:</strong> You can write simple scripts
					to automate repetitive tasks, saving you time when working with big
					datasets.</li>
				<li><strong>Works Well with Large Datasets:</strong> Linux
					tools can handle large files without crashing, unlike some GUI
					tools that may struggle with big data.</li>
				<li><strong>Remote Access:</strong> You can easily access and
					run tasks on remote computers or servers using Linux, which is
					especially useful for bioinformatics work.</li>
				<li><strong>Customizable:</strong> You can personalize your
					Linux setup to make it work just the way you want, allowing you to
					create custom workflows.</li>
				<li><strong>Can Process Data Faster with Multiple
						Processors:</strong> Linux supports running tasks on multiple processors at
					once, which speeds up data analysis, especially for big
					bioinformatics jobs.</li>
			</ul>

			<h2>In Short:</h2>
			<p>Linux is fast, efficient, and free, making it ideal for
				bioinformatics work. It lets you process large amounts of data
				quickly, run tools from anywhere, and automate repetitive
				tasks‚Äîadvantages that GUI tools can‚Äôt always match.</p>
		</section>
		 -->
		<section id="intro-linux-commands">
			<h2>üîß Introduction to Linux Commands</h2>
			<p>Linux commands are typed instructions entered into the
				terminal to interact with the operating system. These commands allow
				users to manage files, run programs, inspect data, and automate
				tasks ‚Äî making them especially powerful for bioinformatics and
				scientific computing.</p>

			<h3>üí° Why Learn Linux Commands?</h3>
			<ul>
				<li>Many bioinformatics tools are designed to run on Linux.</li>
				<li>Command-line tools are faster and more efficient for
					processing large datasets.</li>
				<li>Automation is easier using scripts and command
					combinations.</li>
				<li>Remote servers and high-performance clusters often run on
					Linux.</li>
			</ul>

			<h3>üñ•Ô∏è What is the Terminal?</h3>
			<p>The terminal (also called the shell or command line) is a
				text-based interface to the Linux operating system. Instead of
				clicking buttons, you type commands to get things done.</p>
			<h4>üñ•Ô∏è Terminal Access: WSL, macOS Terminal, and Linux Shell</h4>
			<p>The terminal is a text-based interface used to interact with
				the computer‚Äôs operating system. In bioinformatics, it‚Äôs a powerful
				tool for working with data and automating tasks. Here's how to
				access it on different systems:</p>

			<h5>ü™ü Windows ‚Äì WSL (Windows Subsystem for Linux)</h5>
			<ul>
				<li>WSL allows you to run a Linux environment directly on
					Windows without using a virtual machine.</li>
				<li>To open WSL: Press <code>Windows</code> + <code>R</code>,
					type <code>wsl</code>, and hit Enter.
				</li>
				<li>You can also use <strong>Windows Terminal</strong> and
					select a Linux distribution (e.g., Ubuntu).
				</li>
			</ul>

			<h5>üçé macOS ‚Äì Terminal App</h5>
			<ul>
				<li>macOS is based on Unix, so you can use the terminal just
					like Linux.</li>
				<li>To open Terminal: Press <code>Cmd</code> + <code>Space</code>,
					type <code>Terminal</code>, and press Enter.
				</li>
				<li>The macOS terminal supports most common Linux commands.</li>
			</ul>

			<h5>üêß Linux ‚Äì Native Shell</h5>
			<ul>
				<li>Linux systems come with a built-in terminal (usually Bash).</li>
				<li>To open: Look for ‚ÄúTerminal‚Äù in your application menu or
					press <code>Ctrl</code> + <code>Alt</code> + <code>T</code>.
				</li>
				<li>Linux offers full access to all features and commands
					needed in bioinformatics.</li>
			</ul>


			<h3>üìò Basic Command Syntax</h3>
			<p>Most Linux commands follow a simple structure:</p>
			<pre><code>[command] [options] [arguments]</code></pre>
			<p>
				<strong>Example:</strong>
			</p>
			<pre><code>ls -l /home/user</code></pre>
			<p>
				This runs the
				<code>ls</code>
				command (list files), with the
				<code>-l</code>
				option (long format), on the folder
				<code>/home/user</code>
				.
			</p>

			<h3>üß† Tips for Beginners</h3>
			<ul>
				<li>Use the <code>man</code> command to read the manual for any
					command (e.g., <code>man ls</code>).
				</li>
				<li>Use <code>Tab</code> to auto-complete filenames and command
					names.
				</li>
				<li>Use the <code>up arrow</code> to recall previous commands.
				</li>
				<li>Always double-check before running destructive commands
					like <code>rm</code>.
				</li>
			</ul>

			<p>
				üëâ <strong>Tip:</strong> All platforms let you practice the same
				commands. The behavior is almost identical across WSL, macOS, and
				Linux.
			</p>

			<p>In the next sections, you'll learn how to navigate the
				filesystem, manage files, and inspect data using essential Linux
				commands.</p>
		</section>
		<section id="filesystem-structure">
			<h2>üìÅ Filesystem Structure and Layout</h2>
			<p>
				The Linux filesystem is organized as a single directory tree
				starting from the root directory
				<code>/</code>
				. Understanding this layout helps you navigate and find your files
				efficiently.
			</p>

			<ul>
				<li><code>/</code> ‚Äî The root directory, the top-level folder
					of the entire system.</li>
				<li><code>/home</code> ‚Äî Contains user home directories, where
					personal files and settings are stored (e.g., <code>/home/username</code>).</li>
			</ul>
			<img src="resources/filestructure.png" alt="Linux Filesystem Structure" style="max-width:100%; height:auto; border:1px solid #ccc; border-radius:8px;">
			<p>
				In bioinformatics, most of your work will happen inside your home
				directory under
				<code>/home/username</code>
				, where you can create and organize project files safely.
			</p>
		</section>



		


		<section id="filesystem">
			<h2>Filesystem Navigation in Linux (via WSL, Linux, or macOS)</h2>
			<p>Understanding how to navigate the file system is essential for
				working in the Linux terminal. Let‚Äôs go over the fundamental
				commands used for navigation.</p>

			<h3>1. Key Commands</h3>
			<ul>
				<li><strong> Print Working Directory: </strong> This command
					shows the <strong>current directory</strong> you are in.

					<div class="code_div">
						<code class="codeStyle">pwd</code>
						<button class="copy-btn">Copy</button>
					</div> Example output: <code>/home/user/Documents</code></li>

				<li><strong>List:</strong> This command lists all files and
					directories in the <strong>current directory</strong>.
					<div class="code_div">
						<code class="codeStyle">ls</code>
						<button class="copy-btn">Copy</button>
					</div> Example output: <code>Documents Pictures Downloads Music</code> <br />
					<ul>
						<li>Use
							<div class="code_div">
								<code class="codeStyle">ls -a</code>
								<button class="copy-btn">Copy</button>
							</div> to show hidden files (files starting with a dot).

						</li>
					</ul></li>

				<li><strong>Change Directory:</strong> This command allows you
					to <strong>move into a different directory</strong>. <code>cd
						Documents</code> (if it exists in the current directory).
					<ul>
						<li>To go up one level, use <code>cd Documents</code>
						</li>
					</ul></li>
			</ul>

			<h3>2. Absolute vs. Relative Paths</h3>
			<p>
				There are two types of paths used for navigation in Linux: <strong>absolute
					paths</strong> and <strong>relative paths</strong>.
			</p>
			<ul>
				<li><strong>Absolute Path:</strong> This is the full path to a
					file or directory, starting from the root directory <code>/</code>
					Example output: <code>/home/user/Documents</code> it is a <strong>complete
						reference</strong> to the file or directory location.</li>

				<li><strong>Relative Path:</strong> This refers to a location <strong>relative
						to the current directory</strong>. <code>cd Documents</code> If you're
					currently in the <code>/home/user/</code> directory, this will take
					you to <code>/home/user/Documents</code>.
					<ul>
						<li>Use <code>cd ..</code> to move to the parent directory.
						</li>
					</ul></li>
			</ul>

			<h3>3. Example Walkthrough</h3>
			<p>Let‚Äôs assume your file structure looks like this:</p>
			<pre>
				<code>
  /Users/
	‚îú‚îÄ‚îÄlhbarboza/
		  ‚îú‚îÄ‚îÄ Documents/
		  ‚îú‚îÄ‚îÄ Music/
		  ‚îî‚îÄ‚îÄ Pictures/
    </code>
			</pre>

			<ol>
				<li><strong><code>pwd</code></strong> (Print Working
					Directory): If you're currently in the <code>/home/user/</code>
					directory, typing

					<div class="code_div">
						<code class="codeStyle">pwd</code>
						<button class="copy-btn">Copy</button>
					</div> will display: <code>/Users/lhbarboza</code></li>

				<li><strong><code>ls</code></strong> (List Contents): To list
					the contents of <code>/home/user/</code>, type:
					<div class="code_div">
						<code class="codeStyle">ls</code>
						<button class="copy-btn">Copy</button>
					</div> Output: <code>Documents Music Pictures</code></li>

				<li><strong><code>cd</code></strong> (Change Directory): To
					move into the <code>Documents</code> directory, type:
					<div class="code_div">
						<code class="codeStyle">cd Documents</code>
						<button class="copy-btn">Copy</button>
					</div></li>

				<li><strong><code>pwd</code> again:</strong> After changing
					into the <code>Documents</code> directory, typing
					<div class="code_div">
						<code class="codeStyle">pwd</code>
						<button class="copy-btn">Copy</button>
					</div> again will display: <code>/home/user/Documents</code></li>

				<li><strong>Absolute Path Example:</strong> To go to the <code>Music</code>
					directory from anywhere, you can use the absolute path:
					<div class="code_div">
						<code class="codeStyle">cd /home/user/Music</code>
						<button class="copy-btn">Copy</button>
					</div></li>

				<li><strong>Relative Path Example:</strong> If you're in the <code>Documents</code>
					directory and want to move up one level to <code>/home/user/</code>,
					use:
					<div class="code_div">
						<code class="codeStyle">cd ..</code>
						<button class="copy-btn">Copy</button>
					</div></li>
			</ol>
			<h3>4. Activity: Navigate to a Folder and Explore Its Contents</h3>
			<p>Let‚Äôs practice navigating the file system!</p>
			<ol>
				<li><strong>Navigate to a folder:</strong> <br /> - Open your
					terminal (WSL/Linux/macOS). <br /> - Use the <code>pwd</code>
					command to check your current directory. <br /> - Use <code>ls</code>
					to list the contents. - Move into a subdirectory using <code>
						cd
						<folder_name>
					</code>.<br /> - Try using both absolute and relative paths.</li>

				<li><strong>Explore directory contents:</strong> <br /> - Use
					<code>ls -l</code> to list files with details (permissions, file
					size, etc.). <br /> - Use <code>ls -a</code> to show hidden files.
					<br /> - Use <code>cd ..</code> to go up one level in the
					directory.</li>

				<li><strong>Create a new file and directory:</strong> <br /> -
					Create a new directory with: <pre><code>mkdir NewFolder</code></pre> 
					- Create a new file with: <pre><code>touch newfile.txt</code></pre> 
					- List the contents with <code>ls</code> to confirm the changes.</li>
			</ol>


		</section>
		<section id="filemanagement">
			<h2>File Management in Linux (via WSL, Linux, or macOS)</h2>
			<p>Understanding file management is crucial for organizing your
				data and projects. Let‚Äôs cover some essential file management
				commands in Linux.</p>

			<h3>1. Key File Management Commands</h3>
			<ul>
				<li><strong><code>mkdir</code> (Make Directory):</strong> This
					command allows you to create a new directory (folder). 
					<pre><code>mkdir project_folder</code></pre> Example output: (No output is returned on success, but the
					directory is created.)</li>

				<li><strong><code>touch</code> (Create Empty File):</strong>
					This command is used to create an empty file. It can also be used
					to update the timestamp of an existing file. 
					<pre><code>touch newfile.txt</code></pre> 
					Example output: (No output is returned on success, but the file is
					created.)</li>

				<li><strong><code>cp</code> (Copy Files/Directories):</strong>
					This command is used to copy files or directories. 
					<pre><code>cp file1.txt file2.txt</code></pre> 
					This copies `file1.txt` to `file2.txt`. 
					<pre><code>cp -r folder1 folder2</code></pre> 
					The `-r` option is used to copy directories recursively.</li>

				<li><strong><code>mv</code> (Move/Rename
						Files/Directories):</strong> This command moves or renames files and
					directories. 
					<pre><code>mv oldname.txt newname.txt</code></pre> 
					Example: This renames `oldname.txt` to `newname.txt`. 
					<pre><code>mv file1.txt /path/to/destination/</code></pre> 
					This moves `file1.txt` to a new directory.</li>

				<li><strong><code>rm</code> (Remove/Delete
						Files/Directories):</strong> This command is used to remove files or
					directories. 
					<pre><code>rm file1.txt</code></pre> 
					This deletes `file1.txt`. Be cautious as this is permanent. 
					<pre><code>rm -r folder1</code></pre> 
					The `-r` option allows you to remove directories and their
					contents recursively.</li>
			</ul>

			<h3>2. Creating and Organizing Directories</h3>
			<p>Creating a structured directory system is essential for
				organizing project files. Here's how you can organize your data:</p>

			<ul>
				<li><strong>Creating a new project directory:</strong> Use <code>mkdir</code>
					to create a new directory for your project: 
					<pre><code>mkdir my_project</code></pre> 
					This will create a directory called `my_project`.</li>

				<li><strong>Creating subdirectories:</strong> You can create
					multiple directories within your project folder to keep files
					organized: 
					<pre><code>mkdir my_project/input my_project/output my_project/scripts</code></pre> 
					This will create three subdirectories within `my_project` for
					
					organizing input data, output files, and scripts.</li>

				<li><strong>Creating files inside directories:</strong> Once
					you've set up your directories, you can create files in them using
					the <code>touch</code> command: 
					<pre><code>touch my_project/input/data.txt my_project/scripts/analysis.py</code></pre> 
					This will create two files: one in the `input` folder (`data.txt`)
					and another in the `scripts` folder (`analysis.py`).</li>
			</ul>

			<h3>3. Example Walkthrough: Organizing a Project</h3>
			<p>Let's walk through creating a project folder and organizing
				files:</p>
			<ul>
				<li><strong>Create the project folder:</strong>
					<div class="code_div">
						<code class="codeStyle">mkdir my_bioinformatics_project</code>
						<button class="copy-btn">Copy</button>
					</div> This creates the main folder for your project.</li>

				<li><strong>Create subdirectories:</strong>
					<div class="code_div">
						<code class="codeStyle">mkdir
							my_bioinformatics_project/data my_bioinformatics_project/results
							my_bioinformatics_project/scripts</code>
						<button class="copy-btn">Copy</button>
					</div> This organizes your project into folders for data, results, and
					scripts.</li>

				<li><strong>Create files:</strong>
					<div class="code_div">
						<code class="codeStyle">touch
							my_bioinformatics_project/data/input_file.txt</code>
						<button class="copy-btn">Copy</button>
					</div>
					<div class="code_div">
						<code class="codeStyle">touch
							my_bioinformatics_project/scripts/preprocessing.sh</code>
						<button class="copy-btn">Copy</button>
					</div> These files are created inside the appropriate directories.</li>

				<li><strong>Copy files into the project folder:</strong>
					<div class="code_div">
						<code class="codeStyle">cp /path/to/external/input_file.txt
							my_bioinformatics_project/data/</code>
						<button class="copy-btn">Copy</button>
					</div> This copies an existing file into the `data` directory.</li>

				<li><strong>Move files:</strong> If you want to reorganize, use
					<code>mv</code>:
					<div class="code_div">
						<code class="codeStyle">mv
							my_bioinformatics_project/scripts/preprocessing.sh
							my_bioinformatics_project/scripts/analysis.sh</code>
						<button class="copy-btn">Copy</button>
					</div> This renames the `preprocessing.sh` file to `analysis.sh`.</li>

				<li><strong>Delete unnecessary files:</strong> If a file is no
					longer needed, use <code>rm</code> to remove it:
					<div class="code_div">
						<code class="codeStyle">rm
							my_bioinformatics_project/data/old_data.txt</code>
						<button class="copy-btn">Copy</button>
					</div> This removes the old data file from your project.</li>
			</ul>

			<!-- <h3>4. Activity: Set Up a Project Folder with Dummy Files</h3>
			<p>Let‚Äôs practice by setting up a project folder and organizing
				it!</p>
			<ol>
				<li><strong>Create the project directory:</strong> <br /> -
					Open your terminal (WSL/Linux/macOS). <br /> - Run the following
					command: 
					<pre><code>mkdir bioinformatics_project</code></pre>
					</li>

				<li><strong>Create subdirectories for data, scripts,
						and results:</strong> <br /> - Create the following directories: 
						<pre><code>mkdir bioinformatics_project/data bioinformatics_project/scripts bioinformatics_project/results</code></pre></li>

				<li><strong>Create some files:</strong> <br /> - Use the <code>touch</code>command
					to create dummy files: 
					<pre><code>touch bioinformatics_project/data/input_file.txt</code></pre> 
					<pre><code>touch bioinformatics_project/scripts/analysis.sh</code></pre>
					</li>

				<li><strong>Copy a file into the project:</strong> <br /> - If
					you have an existing file (e.g., <code>sample_data.txt</code>),
					copy it into the project folder: 
					<pre><code>cp sample_data.txt bioinformatics_project/data/</code></pre>
					</li>

				<li><strong>Rename a file:</strong> <br /> - Rename the file
					analysis.sh` to `preprocessing.sh`: 
					<pre><code>mv bioinformatics_project/scripts/analysis.sh bioinformatics_project/scripts/preprocessing.sh</code></pre>
					</li>

				<li><strong>Delete unnecessary files:</strong> <br /> - If
					there are files you no longer need, delete them with <code>rm</code>:
					<pre><code>rm bioinformatics_project/data/old_file.txt</code></pre>
					</li>
			</ol> -->
		</section>
		<section id="file-permission">
  <h2>File Permission and Ownership</h2>
  <p>
    In Linux, every file and directory has associated permissions and an owner. These define who can read, write, or execute the file.
  </p>

  <h3>Permission Structure</h3>
  <img src="resources/filepermission.png" alt="file permission" style="max-width:100%; height:auto; border:1px solid #ccc; border-radius:8px;">
  <p>
    File permissions are displayed using symbols like <code>-rwxr-xr--</code>:
  </p>
  <ul>
    <li>The first character indicates type (<code>-</code> for files, <code>d</code> for directories)</li>
    <li>The next 3 characters are for the owner</li>
    <li>The next 3 are for the group</li>
    <li>The last 3 are for others</li>
  </ul>

  <h3>Common Commands</h3>
  <ul>
    <li><code>chmod</code> ‚Äì change permissions</li>
    <li><code>chown</code> ‚Äì change file ownership</li>
    <li><code>chgrp</code> ‚Äì change group ownership</li>
  </ul>

  <h2>Understanding File Permissions with <code>chmod</code></h2>
  <p>In bioinformatics workflows, you often work with scripts, data files, and executables. Managing who can read, write, or execute these files is crucial to maintaining security and proper collaboration, especially when working on shared systems or clusters.</p>

  <h3>What is <code>chmod</code>?</h3>
  <p>The <code>chmod</code> command in Linux changes the permissions of a file or directory. Permissions determine who can read (<code>r</code>), write (<code>w</code>), or execute (<code>x</code>) a file.</p>

  <h3>Basic Permissions Breakdown</h3>
  <ul>
    <li><strong>Read (<code>r</code>):</strong> Allows viewing the contents of a file or listing a directory.</li>
    <li><strong>Write (<code>w</code>):</strong> Allows modifying a file or adding/removing files in a directory.</li>
    <li><strong>Execute (<code>x</code>):</strong> Allows running a file as a program or script, or accessing a directory.</li>
  </ul>

  <h3>Permission Categories</h3>
  <p>Permissions are assigned to three groups:</p>
  <ul>
    <li><strong>User (u):</strong> The file owner.</li>
    <li><strong>Group (g):</strong> Other users in the file‚Äôs group.</li>
    <li><strong>Others (o):</strong> Everyone else.</li>
  </ul>

  <h3>Using <code>chmod</code></h3>
  <p>Permissions can be set using symbolic or numeric modes.</p>

  <h4>Symbolic Mode</h4>
  <p>You specify who (u, g, o), what action (+ to add, - to remove, = to set), and which permission (r, w, x).</p>
  <pre><code>chmod u+x script.sh</code></pre>
  <p>This command adds execute permission for the file owner on <code>script.sh</code>.</p>

  <h4>Numeric Mode</h4>
  <p>Permissions are represented by numbers: read = 4, write = 2, execute = 1. Add them up for each category:</p>
  <ul>
    <li><code>7</code> = read + write + execute (4+2+1)</li>
    <li><code>6</code> = read + write (4+2)</li>
    <li><code>5</code> = read + execute (4+1)</li>
    <li><code>4</code> = read only</li>
  </ul>
  <p>Example:</p>
  <pre><code>chmod 755 script.sh</code></pre>
  <p>This sets permissions to <code>rwxr-xr-x</code>: full permissions for user, and read + execute for group and others.</p>

	<h3><code>chown</code> ‚Äî Change File Owner</h3>
  <p>The <code>chown</code> command changes the owner of a file or directory. Ownership is important for file access and management.</p>
  <p><strong>Syntax:</strong></p>
  <pre><code>chown new_owner filename</code></pre>
  <p><strong>Example:</strong></p>
  <pre><code>chown alice genes.gff</code></pre>
  <p>This changes the owner of <code>genes.gff</code> to the user <code>alice</code>.</p>
  <p><strong>Change owner recursively:</strong></p>
  <pre><code>chown -R alice bioinfo_folder/</code></pre>
  <p>This changes the owner of <code>bioinfo_folder</code> and all files/subfolders inside.</p>

  <h3><code>chgrp</code> ‚Äî Change File Group</h3>
  <p>The <code>chgrp</code> command changes the group ownership of a file or directory.</p>
  <p><strong>Syntax:</strong></p>
  <pre><code>chgrp new_group filename</code></pre>
  <p><strong>Example:</strong></p>
  <pre><code>chgrp bioinfo_team reads.fastq</code></pre>
  <p>This sets the group of <code>reads.fastq</code> to <code>bioinfo_team</code>.</p>
  <p><strong>Change group recursively:</strong></p>
  <pre><code>chgrp -R bioinfo_team bioinfo_folder/</code></pre>
  <p>This changes the group ownership of <code>bioinfo_folder</code> and all its contents.</p>
	
  <h3>Why is <code>chmod</code> Important in Bioinformatics?</h3>
  <p>Many bioinformatics tools and scripts must be executable to run. For example, if you download a pipeline script (<code>pipeline.sh</code>), you might need to make it executable:</p>
  <pre><code>chmod +x pipeline.sh</code></pre>
  <p>Additionally, sharing data or scripts securely means restricting write access to trusted users only, preventing accidental overwrites.</p>

</section>
		
		<section id="compressed">
  <h2>Compressing and Decompressing Files in Linux</h2>

  <p>You can compress the <code>bioinfo_viewing_practice</code> folder using various tools available in Linux.</p>

  <h3>1. ZIP Format (.zip)</h3>
  <p><strong>Compress:</strong></p>
  <pre><code>zip -r bioinfo_viewing_practice.zip bioinfo_viewing_practice</code></pre>
  <p><strong>Decompress:</strong></p>
  <pre><code>unzip bioinfo_viewing_practice.zip</code></pre>

  <h3>2. TAR Archive (.tar)</h3>
  <p><strong>Compress:</strong></p>
  <pre><code>tar -cvf bioinfo_viewing_practice.tar bioinfo_viewing_practice</code></pre>
  <p><strong>Decompress:</strong></p>
  <pre><code>tar -xvf bioinfo_viewing_practice.tar</code></pre>

  <h3>3. Gzip-Compressed TAR Archive (.tar.gz)</h3>
  <p><strong>Compress:</strong></p>
  <pre><code>tar -czvf bioinfo_viewing_practice.tar.gz bioinfo_viewing_practice</code></pre>
  <p><strong>Decompress:</strong></p>
  <pre><code>tar -xzvf bioinfo_viewing_practice.tar.gz</code></pre>

  <h3>4. Bzip2-Compressed TAR Archive (.tar.bz2)</h3>
  <p><strong>Compress:</strong></p>
  <pre><code>tar -cjvf bioinfo_viewing_practice.tar.bz2 bioinfo_viewing_practice</code></pre>
  <p><strong>Decompress:</strong></p>
  <pre><code>tar -xjvf bioinfo_viewing_practice.tar.bz2</code></pre>

  <h3>üìã Summary Table</h3>
  <table border="1" cellpadding="8" cellspacing="0">
    <thead>
      <tr>
        <th>Format</th>
        <th>File Extension</th>
        <th>Compress Command</th>
        <th>Decompress Command</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td>ZIP</td>
        <td>.zip</td>
        <td><code>zip -r file.zip folder</code></td>
        <td><code>unzip file.zip</code></td>
      </tr>
      <tr>
        <td>TAR</td>
        <td>.tar</td>
        <td><code>tar -cvf file.tar folder</code></td>
        <td><code>tar -xvf file.tar</code></td>
      </tr>
      <tr>
        <td>TAR + Gzip</td>
        <td>.tar.gz / .tgz</td>
        <td><code>tar -czvf file.tar.gz folder</code></td>
        <td><code>tar -xzvf file.tar.gz</code></td>
      </tr>
      <tr>
        <td>TAR + Bzip2</td>
        <td>.tar.bz2</td>
        <td><code>tar -cjvf file.tar.bz2 folder</code></td>
        <td><code>tar -xjvf file.tar.bz2</code></td>
      </tr>
    </tbody>
  </table>

  <h3>‚öôÔ∏è Explanation of Flags/Arguments</h3>
  <ul>
    <li><code>-r</code> (zip): Recursively include files and directories.</li>
    <li><code>-c</code> (tar): Create a new archive.</li>
    <li><code>-x</code> (tar): Extract files from an archive.</li>
    <li><code>-v</code> (tar): Verbose mode; shows progress (list files being processed).</li>
    <li><code>-f</code> (tar): Specify the archive file name.</li>
    <li><code>-z</code> (tar): Filter the archive through gzip compression.</li>
    <li><code>-j</code> (tar): Filter the archive through bzip2 compression.</li>
  </ul>

  <p>üìù <strong>Note:</strong> Unless you specify a path for the archive, compressed files are created in your current working directory.</p>
</section>
<section id="viewing">
  <h2>Viewing Files in Linux (via WSL, Linux, or macOS)</h2>
  <p>In bioinformatics, you often deal with large datasets, and
    knowing how to efficiently view files is crucial. In this section,
    we will explore several commands that can help you view the contents
    of files in the terminal.</p>
    Download this file: <a
					href="/bbc2025v1/docs/2025/module1_basic_linux/resources/bioinfo_viewing_practice.zip"><strong>bioinfo_viewing.zip</strong></a>.</br>
					Download this file: <a
					href="/bbc2025v1/docs/2025/module1_basic_linux/resources/bioinfo_viewing_practice.tar"><strong>bioinfo_viewing.tar</strong></a>.</br>
					Download this file: <a
					href="/bbc2025v1/docs/2025/module1_basic_linux/resources/bioinfo_viewing_practice.tar.bz2"><strong>bioinfo_viewing.tar.bz2</strong></a>.</br>
					Download this file: <a
					href="/bbc2025v1/docs/2025/module1_basic_linux/resources/bioinfo_viewing_practice.tar.gz"><strong>bioinfo_viewing.tar.gz</strong></a>.</br>
				

  <h3>1. Key Commands for Viewing Files</h3>
  <ul>
    <li><strong><code>cat</code> (Concatenate and View
        File Contents):</strong> The <code>cat</code> command is used to display
      the contents of a file directly in the terminal. It's best used for
      small files, as it prints the entire file at once. 
      <pre><code>cat sequence.fasta</code></pre> 
      Example output: 
      <pre><code>&gt;seq1
ATGCGTACGTAGCTAGCTAGCTA</code></pre>
      <p>
        <strong>Warning:</strong> Avoid using
        <code>cat</code>
        for large files, as it may overwhelm the terminal.
      </p></li>

    <li><strong><code>less</code> (View File
        Page-by-Page):</strong> The <code>less</code> command is useful for viewing
      large files, as it allows you to scroll through the file one page
      at a time. <pre><code>less reads.fastq</code></pre> 
      You can navigate using:
      <ul>
        <li><code>Space</code>: Scroll down one page</li>
        <li><code>Up/Down Arrow</code>: Move one line up/down</li>
        <li><code>q</code>: Quit and return to the terminal</li>
      </ul></li>

    <li><strong><code>head</code> (View the First Few
        Lines of a File):</strong> The <code>head</code> command shows the first 10
      lines of a file by default. It‚Äôs useful when you want to quickly
      check the beginning of a large file. 
      <pre><code>head genes.gff</code></pre> 
      To view a specific number of lines, use the <code>-n</code>
      option: 
      <pre><code>head -n 20 genes.gff</code></pre> 
      This shows the first 20 lines of the file.</li>

    <li><strong><code>tail</code> (View the Last Few Lines
        of a File):</strong> The <code>tail</code> command is the opposite of <code>head</code>;
      it shows the last 10 lines of a file by default. It‚Äôs useful for
      monitoring log files or large datasets where the latest information
      is more relevant. 
      <pre><code>tail alignment.sam</code></pre> 
      To view the last few lines or monitor a file in real-time, use: 
      <pre><code>tail -n 20 alignment.sam</code></pre> 
      This shows the last 20 lines of the file. 
      <pre><code>tail -f alignment.sam</code></pre> 
      The <code>-f</code> option allows you to follow a file in
      real-time (useful for logs).</li>
  </ul>

  <h3>2. Best Tools for Viewing Large Data Files</h3>
  <p>When working with large data files, it's important to use the
    right tool to avoid overwhelming your terminal. Here‚Äôs a breakdown
    of the best tools:</p>
  <ul>
    <li><strong><code>less</code>:</strong> Ideal for viewing large
      files, as it loads the file one page at a time. You can scroll
      through the content and search within the file using <code>/search_term</code>
      and <code>n</code> to go to the next occurrence.</li>
    <li><strong><code>head</code> and <code>tail</code>:</strong>
      These are best when you only need to view the beginning or the end
      of the file, respectively. They are more efficient than loading the
      entire file into the terminal.</li>
    <li><strong><code>cat</code>:</strong> Only recommended for
      small files, as it prints the entire file to the terminal.</li>
  </ul>

  <h3>3. Example Walkthrough: Viewing Large Files</h3>
  <p>Let‚Äôs walk through the process of using these commands to view
    a large file, such as a `.fasta`, `.fastq`, `.gff`, `.sam`, or `.tsv` file.</p>

  <ul>
    <li><strong>View a small file using <code>cat</code>:
      </strong> For a small file, simply use:
      <div class="code_div">
        <code class="codeStyle">cat sequence.fasta</code>
        <button class="copy-btn">Copy</button>
      </div> This will display the entire contents of <code>sequence.fasta</code> at once.
    </li>

    <li><strong>View a large file using <code>less</code>:
      </strong> If the file is large, use:
      <div class="code_div">
        <code class="codeStyle">less reads.fastq</code>
        <button class="copy-btn">Copy</button>
      </div> This will allow you to scroll through the content one page at a
      time, making it much easier to navigate large files.</li>

    <li><strong>View the first few lines of a file using <code>head</code>:
      </strong> If you only want to check the beginning of the file, use:
      <div class="code_div">
        <code class="codeStyle">head genes.gff</code>
        <button class="copy-btn">Copy</button>
      </div> This will show the first 10 lines by default.</li>

    <li><strong>View the last few lines of a file using <code>tail</code>:
      </strong> To quickly check the end of a file (e.g., for logs or recent data),
      use:
      <div class="code_div">
        <code class="codeStyle">tail alignment.sam</code>
        <button class="copy-btn">Copy</button>
      </div> To monitor the file in real-time (for example, a log file that
      updates constantly), use:
      <div class="code_div">
        <code class="codeStyle">tail -f alignment.sam</code>
        <button class="copy-btn">Copy</button>
      </div></li>
  </ul>
</section>
		
		<section>
		<h2><a href="cheatsheet_day1.html" target="_blank">Cheat Sheet day 1</a></h2>
		</section>
		
	<section id="hard-soft">
    <h2>üîó What are Links?</h2>
    <p>Links in Linux are like shortcuts. They help us access a file using another name or location.</p>
    <p>There are two types of links:</p>
    <ul>
      <li><strong>Hard Links</strong></li>
      <li><strong>Soft Links (Symbolic Links or Symlinks)</strong></li>
    </ul>
  
    <h3>üß± Hard Links</h3>
    <p>A hard link is another name for the same file. Both names point to the same data.</p>
    <p><strong>Simple Facts:</strong></p>
    <ul>
      <li>Hard links share the same content.</li>
      <li>If you delete one, the other still works.</li>
      <li>Cannot be used for folders or across disks.</li>
    </ul>
    <p><strong>Example:</strong></p>
    <pre><code>touch file1.txt
ln file1.txt hardlink.txt
</code></pre>
    <p>Now both <code>file1.txt</code> and <code>hardlink.txt</code> are the same file.</p>
  
    <h3>ü™¢ Soft Links (Symbolic Links)</h3>
    <p>A soft link is like a shortcut. It points to the location of another file or folder.</p>
    <p><strong>Simple Facts:</strong></p>
    <ul>
      <li>Points to the path, not the file itself.</li>
      <li>Can link to folders or files.</li>
      <li>Works across disks or partitions.</li>
      <li>Breaks if the original file is deleted.</li>
    </ul>
    <p><strong>Example:</strong></p>
    <pre><code>ln -s file1.txt softlink.txt</code></pre>
    <pre><code>ln -s /full/path/to/folder1/real.txt folder2/softlink.txt</code></pre>
    <pre><code>ln -s ../folder1/real.txt softlink.txt</code></pre>
    <p><code>softlink.txt</code> now points to <code>file1.txt</code>.</p>
  

    <h2>üìä Quick Comparison</h2>
    <table border="1" cellpadding="8">
      <tr>
        <th>Feature</th>
        <th>Hard Link</th>
        <th>Soft Link</th>
      </tr>
      <tr>
        <td>Points to</td>
        <td>File content (inode)</td>
        <td>File path</td>
      </tr>
      <tr>
        <td>Works across disks</td>
        <td>No</td>
        <td>Yes</td>
      </tr>
      <tr>
        <td>Breaks if original is deleted</td>
        <td>No</td>
        <td>Yes</td>
      </tr>
      <tr>
        <td>Can link to folders</td>
        <td>No</td>
        <td>Yes</td>
      </tr>
    </table>

    <h2>‚úÖ Try It Yourself</h2>
    <p>Open your terminal and try these steps:</p>
    <ol>
      <li><code>touch sample.txt</code> ‚Äì create a file</li>
      <li><code>echo "Hello!" > sample.txt</code> ‚Äì add some text</li>
      <li><code>ln sample.txt hardcopy.txt</code> ‚Äì make a hard link</li>
      <li><code>ln -s sample.txt softcopy.txt</code> ‚Äì make a soft link</li>
      <li><code>ls -li</code> ‚Äì view the files and links</li>
    </ol>
  </section>

		
		<section id="bioinformatics-file-formats">
			<h2>Bioinformatics File Formats</h2>
			<p>Bioinformatics relies on various file formats to store and
				exchange biological data. Below is an overview of some commonly used
				formats:</p>

			<dl>
				<dt>
					<strong>FASTQ</strong>
				</dt>
				<dd>
					A format for storing raw sequencing reads, typically compressed as
					<code>fastq.gz</code>
					. Each entry includes a sequence identifier, nucleotide sequence, a
					plus sign separator, and a quality score line. Essential for
					next-generation sequencing data analysis.
				</dd>

				<dt>
					<strong>FASTA</strong>
				</dt>
				<dd>A text-based format for representing nucleotide or peptide
					sequences. Each sequence begins with a header line starting with
					'>', followed by the sequence identifier and the sequence itself.
					Widely used for sequence alignment and database searches.</dd>

				<dt>
					<strong>Multi-FASTA</strong>
				</dt>
				<dd>Similar to FASTA but contains multiple sequences within a
					single file. Each sequence is separated by a header line, allowing
					for batch processing of sequences.</dd>

				<dt>
					<strong>GFF3 (General Feature Format Version 3)</strong>
				</dt>
				<dd>A format for describing genes and other features of DNA,
					RNA, and protein sequences. Each line represents a feature with
					fields for sequence name, source, type, start, end, and attributes.
					Important for annotating genomic features and gene structures.</dd>

				<dt>
					<strong>SAM (Sequence Alignment/Map)</strong>
				</dt>
				<dd>A text format for storing sequence alignment data. It
					includes a header section and an alignment section, with each
					alignment represented by a line containing various fields such as
					sequence name, position, mapping quality, and CIGAR string. SAM
					files are often compressed into BAM files for storage efficiency.</dd>

				<dt>
					<strong>VCF (Variant Call Format)</strong>
				</dt>
				<dd>A text file format for storing gene sequence variations,
					such as single nucleotide polymorphisms (SNPs) and
					insertions/deletions (InDels). Each line represents a variant,
					including information such as chromosome, position, and genotype.
					Crucial for genomic studies, particularly in identifying genetic
					variations.</dd>
			</dl>
		</section>
		
		<section id="pattern-matching">
			<h2>üîé Pattern Matching in Bash</h2>
			Download this file: <a
					href="/bbc2025v1/docs/2025/module1_basic_linux/resources/globbing-demo.zip"><strong>patternMatching_practice.zip</strong></a>.

			<h3>üåü Globbing (Wildcard Expansion)</h3>
			<p>Globbing lets you match file or folder names using special
				characters called wildcards:</p>
			<ul>
				<li><code>*</code>: Matches any number of characters (including
					none)</li>
				<li><code>?</code>: Matches exactly one character</li>
				<li><code>[abc]</code>: Matches one of the characters 'a', 'b',
					or 'c'</li>
				<li><code>[a-z]</code>: Matches any lowercase letter from a to
					z</li>
			</ul>
			<h3>üß™ Globbing Examples</h3>

				<h4>* ‚Äî Matches any number of characters (including none)</h4>
				<p>This wildcard is commonly used to match any file that starts or ends with a specific pattern.</p>
				<pre><code>ls *.txt</code></pre>
				<ul>
				  <li>Matches: <code>notes.txt</code>, <code>report.txt</code>, <code>.txt</code></li>
				  <li>Does not match: <code>notes.md</code></li>
				</ul>
				
				<h4>? ‚Äî Matches exactly one character</h4>
				<p>This matches any file with one character in a specific position.</p>
				<pre><code>ls file?.csv</code></pre>
				<ul>
				  <li>Matches: <code>file1.csv</code>, <code>fileA.csv</code></li>
				  <li>Does not match: <code>file12.csv</code>, <code>file.csv</code></li>
				</ul>
				
				<h4>[abc] ‚Äî Matches one of the characters 'a', 'b', or 'c'</h4>
				<p>Use brackets to match one character from a specific set.</p>
				<pre><code>ls test[abc].log</code></pre>
				<ul>
				  <li>Matches: <code>testa.log</code>, <code>testb.log</code>, <code>testc.log</code></li>
				  <li>Does not match: <code>testd.log</code>, <code>testab.log</code></li>
				</ul>
				
				<h4>[a-z] ‚Äî Matches any lowercase letter from a to z</h4>
				<p>You can use ranges inside brackets to simplify pattern matching.</p>
				<pre><code>ls sample[a-z].txt</code></pre>
				<ul>
				  <li>Matches: <code>samplea.txt</code>, <code>samplem.txt</code>, <code>samplez.txt</code></li>
				  <li>Does not match: <code>sample1.txt</code>, <code>sample.txt</code></li>
				</ul>


			<h3>üìò Regular Expressions (Regex) ‚Äî Light Intro</h3>
			<p>
				Regular expressions are patterns used to match text. These can be
				used with text-viewing tools (like
				<code>cat</code>
				) and later with tools like
				<code>grep</code>
				.
			</p>
			<ul>
				<li><code>.</code>: Matches any single character</li>
				<li><code>*</code>: Repeats the previous pattern zero or more
					times</li>
				<li><code>^</code>: Anchors the match to the beginning of a
					line</li>
				<li><code>$</code>: Anchors the match to the end of a line</li>
			</ul>
			<h3>üß™ Regular Expression Examples (Basic)</h3>

				
				<p><code>.</code> matches <strong>any single character</strong>.</p>
				<pre><code>grep "c.t" words.txt</code></pre>
				<ul>
				  <li>Matches: <code>cat</code>, <code>cut</code>, <code>cot</code></li>
				  <li>Does not match: <code>ct</code>, <code>cart</code></li>
				</ul>
				
				<p><code>*</code> means "repeat the previous pattern zero or more times."</p>
				<pre><code>grep "lo*l" words.txt</code></pre>
				<ul>
				  <li>Matches: <code>ll</code>, <code>lol</code>, <code>lool</code>, <code>loooool</code></li>
				  <li>Does not match: <code>lal</code>, <code>lil</code></li>
				</ul>
				
				
				<p><code>^</code> anchors the match to the <strong>start of the line</strong>.</p>
				<pre><code>grep "^ATG" words.txt</code></pre>
				<ul>
				  <li>Matches lines that begin with: <code>ATG</code></li>
				  <li>Does not match lines that contain <code>ATG</code> in the middle or end</li>
				</ul>
				
				
				<p><code>$</code> anchors the match to the <strong>end of the line</strong>.</p>
				<pre><code>grep "GTC$" words.txt</code></pre>
				<ul>
				  <li>Matches lines ending in: <code>GTC</code></li>
				  <li>Does not match: <code>AGTCG</code>, <code>GTCATT</code></li>
				</ul>
			

			<!-- <h3>üîÅ Summary Table</h3>
			<table border="1" cellspacing="0" cellpadding="5">
				<tr>
					<th>Feature</th>
					<th>Globbing</th>
					<th>Regex (Regular Expressions)</th>
				</tr>
				<tr>
					<td>Used For</td>
					<td>File and folder name matching</td>
					<td>Text pattern matching in file contents</td>
				</tr>
				<tr>
					<td>Example</td>
					<td><code>ls *.fasta</code></td>
					<td><code>^GATC</code> (matches lines starting with "GATC")</td>
				</tr>
				<tr>
					<td>Complexity</td>
					<td>Simple</td>
					<td>More flexible and powerful</td>
				</tr>
			</table>
 			-->
			<p>
				We‚Äôll explore tools like
				<code>grep</code>
				and
				<code>awk</code>
				in the next section to put pattern matching into action!
			</p>
		</section>


		<section id="text-processing-tools">
			<h2>üîç Introduction to Text Processing Tools</h2>
			Download this file: <a
					href="/bbc2025v1/docs/2025/module1_basic_linux/resources/textProcessing_practice.zip"><strong>textProcessing_practice.zip</strong></a>.
					
			<p>In bioinformatics, many files are plain text ‚Äî like FASTA,
				GFF, or VCF files. Linux provides powerful tools to read, search,
				and manipulate these files directly from the terminal.</p>
				
			<div class="tip">
			    <strong>üß† Tips:</strong>
			    <ul>
			      <li>To observe the changes made by each command, start by viewing the original file using cat (e.g. cat [filename])</li>
			      
			    </ul>
			  </div>

			
   <h3>üìÑ 1. <code>cat</code> ‚Äì Concatenate and Display File Content (5 mins)</h3>
  <p><strong>Definition:</strong> <code>cat</code> reads files sequentially and writes them to standard output. It's often used to view or merge files.</p>
  <p><strong>Basic Syntax:</strong> <code>cat [filename]</code></p>
  <p><em>1. Displays the contents of a FASTA file directly in the terminal.</em></p>
  <pre><code>cat sequences.fasta</code></pre>
  <p><em>2. Combines two files into one called <code>combined.txt</code>.</em></p>
  <pre><code>cat file1.txt file2.txt > combined.txt</code></pre>
  

  <h3>üîç 2. <code>grep</code> ‚Äì Search for Patterns (15 mins)</h3>
  <p><strong>Definition:</strong> <code>grep</code> searches for lines matching a pattern, often used to locate specific genes, IDs, or mutations.</p>
  <p><strong>Basic Syntax:</strong> <code>grep [options] 'pattern' [file]</code></p>
  <p><em>1. Finds all lines that contain the word "gene" in a GFF file.</em></p>
  <pre><code>grep "gene" genes.gff</code></pre>
  <p><em>2. Case-insensitive search for "chr1" in a VCF file.</em></p>
  <pre><code>grep -i "chr1" variants.vcf</code></pre>
  <p><em>3. Excludes header lines (those starting with <code>#</code>) from the output.</em></p>
  <pre><code>grep -v "^#" variants.vcf</code></pre>
   <ul>
    <li><code>-i</code>: Case-insensitive search</li>
    <li><code>-v</code>: Invert match (exclude matching lines)</li>
    <li><code>-c</code>: Count the number of matches</li>
  </ul>

  <h3>üî™ 3. <code>cut</code> ‚Äì Extract Text Columns (10 mins)</h3>
  <p><strong>Definition:</strong> <code>cut</code> slices text by column, useful for extracting data fields from TSV/CSV/VCF files.</p>
  <p><strong>Basic Syntax:</strong> <code>cut -f[column] -d[delimiter] [file]</code></p>
  <p><em>1. Extracts the first field (Sample ID) from a tab-separated file.</em></p>
  <pre><code>cut -f1 samples.tsv</code></pre>
  <p><em>2. Extracts the second field from a colon-separated file.</em></p>
  <pre><code>cut -d':' -f2 mixed_data.txt</code></pre>
  

  <ul>
    <li><code>-f</code>: Specify field number</li>
    <li><code>-d</code>: Define delimiter (default is tab)</li>
  </ul>

  <h3>üî§ 4. <code>tr</code> ‚Äì Translate or Delete Characters (5 mins)</h3>
  <p><strong>Definition:</strong> <code>tr</code> replaces or removes characters. It's handy for format normalization or case conversion.</p>
  <p><strong>Basic Syntax:</strong> <code>tr [set1] [set2]</code></p>
  <p><em>1. Converts all lowercase letters in a DNA sequence file to uppercase.</em></p>
  <pre><code>cat seq.txt | tr 'a-z' 'A-Z'</code></pre>
  <p><em>2. Removes carriage returns (useful when converting Windows to Unix format).</em></p>
  <pre><code>tr -d '\r' &lt; windows_file.txt</code></pre>
  <p><em>3. Replaces colons with tabs, converting to a tab-delimited format.</em></p>
  <pre><code>tr ':' '\t' &lt; colon_data.txt</code></pre>
  

  <h3>üß† 5. <code>awk</code> ‚Äì Analyze and Format Column Data (15 mins)</h3>
  <p><strong>Definition:</strong> <code>awk</code> is a programming language for pattern scanning and processing. It handles field-based logic and reports.</p>
  <p><strong>Basic Syntax:</strong> <code>awk '{action}' [file]</code></p>
  <p><em>1. Prints the first column (sample names or IDs) from the file.</em></p>
  <pre><code>awk '{print $1}' samples.tsv</code></pre>
  <p><em>2. Filters rows where column 3 equals "gene" and prints selected columns (seqid, start, end).</em></p>
  <pre><code>awk '$3 == "gene" {print $1, $4, $5}' genes.gff</code></pre>
  <p><em>3. Prints variant ID and quality score if quality is greater than 100.</em></p>
  <pre><code>awk -F'\t' '{if ($5 &gt; 100) print $1, $5}' variants.vcf</code></pre>
  

  <h3>‚úÇÔ∏è 6. <code>sed</code> ‚Äì Stream Edit Text In-Place (10 mins)</h3>
  <p><strong>Definition:</strong> <code>sed</code> edits text in a stream. It's useful for substitutions, filtering, and quick text editing in-place.</p>
  <p><strong>Basic Syntax:</strong> <code>sed 's/pattern/replacement/' [file]</code></p>
  <p><em>1. Replaces the first occurrence of "old" with "new" in each line.</em></p>
  <pre><code>sed 's/old/new/' file.txt</code></pre>
  <p><em>2. Replaces all occurrences of "gene" with "GENE" per line.</em></p>
  <pre><code>sed 's/gene/GENE/g' genes.gff</code></pre>
  <p><em>3. Prints only the first 5 lines of the file.</em></p>
  <pre><code>sed -n '1,5p' genes.gff</code></pre>
  

  <ul>
    <li><code>s/old/new/</code>: Replace first match per line</li>
    <li><code>s/old/new/g</code>: Replace all matches per line</li>
    <li><code>-n 'X,Yp'</code>: Print only lines X to Y</li>
  </ul>

<!-- 
  <h3>üéØ Hands-On Tasks (10 mins)</h3>
  <ul>
    <li>üîé <strong><code>grep</code></strong>: Find all genes on chromosome 2  
      <pre><code>grep "chr2" genes.gff</code></pre>
      <p><em>Searches for lines related to chromosome 2 features.</em></p>
    </li>
    <li>‚úÇÔ∏è <strong><code>cut</code></strong>: Extract SampleID and Age  
      <pre><code>cut -f1,3 samples.tsv</code></pre>
      <p><em>Outputs the first and third columns from a TSV file (e.g., Sample ID and Age).</em></p>
    </li>
    <li>üìä <strong><code>awk</code></strong>: Count number of case samples  
      <pre><code>awk '$4 == "case" {count++} END {print count}' samples.tsv</code></pre>
      <p><em>Counts how many samples are labeled as "case" in column 4.</em></p>
    </li>
    <li>üîÅ <strong><code>sed</code></strong>: Replace "fruit" with "FRUIT"  
      <pre><code>sed 's/fruit/FRUIT/g' mixed.txt</code></pre>
      <p><em>Standardizes all "fruit" labels by capitalizing them.</em></p>
    </li>
  </ul>

  <h3>üîó Bonus: Combine Tools with Pipes</h3>
  <p>Use multiple tools together for powerful one-liners:</p>
  <pre><code>grep "gene" genes.gff | cut -f9 | tr ';' '\n' | sort | uniq</code></pre>
  <p><em>Searches for "gene" lines in a GFF file, extracts attributes, splits them into lines, and outputs unique values.</em></p>

		</section>
		 -->
</section><section id="io-redirection">
			<h2>I/O Redirection</h2>
			<p>In Linux, command-line programs typically receive input from
				the keyboard (standard input) and display output on the screen
				(standard output). I/O redirection allows you to change these
				default sources and destinations, enabling you to direct input and
				output to and from files or other commands.</p>
			<h3>Standard Streams</h3>
			<ul>
				<li><strong>Standard Input (stdin):</strong> The default source
					of input, usually the keyboard.</li>
				<li><strong>Standard Output (stdout):</strong> The default
					destination for output, usually the screen.</li>
				<li><strong>Standard Error (stderr):</strong> The default
					destination for error messages, usually the screen.</li>
			</ul>
			<h3>Output Redirection</h3>
			<p>Redirect the output of a command to a file:</p>
			<pre><code>ls > file_list.txt</code></pre>
			<p>
				This command writes the output of
				<code>ls</code>
				to
				<code>file_list.txt</code>
				, overwriting the file if it exists.
			</p>
			<p>Append the output to the end of a file without overwriting:</p>
			<pre><code>ls >> file_list.txt</code></pre>
			<p>
				This command adds the output of
				<code>ls</code>
				to the end of
				<code>file_list.txt</code>
				.
			</p>
			<h3>Input Redirection</h3>
			<p>Use a file as input to a command:</p>
			<pre><code>wc -l < file_list.txt</code></pre>
			<p>
				This command counts the number of lines in
				<code>file_list.txt</code>
				.
			</p>
			<h3>Pipes</h3>
			<p>Use the output of one command as the input to another:</p>
			<pre><code>ls | head -3 > file.txt</code></pre>
			<p>
				This command lists files, takes the first three lines, and writes
				them to
				<code>file.txt</code>
				.
			</p>
		</section>
		<section id="bash-bioinformatics">
  <h2>üíª Understanding Bash Manipulation and Scripting</h2>
  <p><strong>Bash</strong> (Bourne Again SHell) is the command-line shell used in most Linux systems. It allows users to run commands, manipulate text and files, and write scripts to automate repetitive tasks.</p>

  <h3>üß∞ What is Bash Manipulation?</h3>
  <p>Bash manipulation refers to performing tasks directly from the terminal using one-liner commands. These are quick operations used to manage files or extract data.</p>

  <table border="1" cellpadding="8">
    <thead>
      <tr>
        <th>Task</th>
        <th>Command</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td>Rename all .txt files to .bak</td>
        <td><code>for f in *.txt; do mv "$f" "${f%.txt}.bak"; done</code></td>
      </tr>
      <tr>
        <td>Replace text in multiple files</td>
        <td><code>sed -i 's/old/new/g' *.txt</code></td>
      </tr>
      <tr>
        <td>Count number of lines</td>
        <td><code>wc -l data.txt</code></td>
      </tr>
      <tr>
        <td>Extract specific columns</td>
        <td><code>cut -f1,3 data.tsv</code></td>
      </tr>
    </tbody>
  </table>

  <h3>üìù What is Bash Scripting?</h3>
  <p>Bash scripting involves writing a series of Bash commands in a script file (with <code>.sh</code> extension). These scripts can be reused to automate tasks such as file processing, data filtering, or running pipelines.</p>

  <section>
  <h2>üí≤ Using the Dollar Sign in Shell Scripting</h2>

  <p>After covering the essentials ‚Äî <strong>1) script structure, 2) file operations, 3) pattern matching, and 4) input/output</strong> ‚Äî we can explore how the <code>$</code> symbol is used in scripting. This symbol plays a critical role in referencing variables, capturing command output, and working with script arguments.</p>

  <h3>üìå Common Use Cases of <code>$</code> in Shell Scripts</h3>

  <h4>1. üî† Variables and Substitution</h4>
  <pre><code>filename="sample.txt"
echo "The file is named $filename"</code></pre>

  <h4>2. üìÜ Command Substitution</h4>
  <pre><code>today=$(date)
echo "Today's date is: $today"</code></pre>

  <h4>3. üßë‚Äçüíª Script Arguments</h4>
  <pre><code># greet.sh
echo "Hello $1! You provided the file: $2"

# Usage:
./greet.sh Alice data.fasta</code></pre>

  <h4>4. üßæ Special Variables</h4>
  <ul>
    <li><code>$0</code> ‚Äì Script name</li>
    <li><code>$#</code> ‚Äì Number of arguments</li>
    <li><code>$@</code> ‚Äì All arguments</li>
    <li><code>$?</code> ‚Äì Exit status of last command</li>
    <li><code>$$</code> ‚Äì Process ID of the script</li>
  </ul>

  <h4>5. ‚ûó Arithmetic Operations</h4>
  <pre><code>a=10
b=2
result=$((a / b))
echo "Result: $result"</code></pre>

	<h4>üß™ 6. Basic Conditions</h4>
<pre><code>if [ -f "input.txt" ]; then
  echo "File exists"
fi
</code></pre>
<p>üìò Learn more about <code>if</code> conditions here: 
  <a href="https://linuxize.com/post/bash-if-else-statement/" target="_blank">
    Bash Beginners Guide ‚Äì If Statements
  </a>
</p>

<h4>7. üóÉÔ∏è Looping Over Files with <code>$</code></h4>
<p>Although loops go beyond basic syntax, this shows practical use:</p>
<pre><code>for file in *.fasta
do
  echo "Processing $file"
done
</code></pre>
<p>üìò Learn more about <code>for</code> loops here: 
  <a href="https://linuxize.com/post/bash-for-loop/	" target="_blank">
    Bash Beginners Guide ‚Äì Loops
  </a>
</p>


  <h3>üìã Summary of <code>$</code> Use Cases</h3>
  <table border="1" cellpadding="5">
    <tr><th>Expression</th><th>Meaning</th></tr>
    <tr><td><code>$var</code></td><td>Access variable value</td></tr>
    <tr><td><code>$(command)</code></td><td>Command substitution</td></tr>
    <tr><td><code>$1, $2, ...</code></td><td>Script arguments</td></tr>
    <tr><td><code>$#</code></td><td>Number of arguments</td></tr>
    <tr><td><code>$@</code></td><td>All arguments</td></tr>
    <tr><td><code>$?</code></td><td>Exit status</td></tr>
    <tr><td><code>$((...))</code></td><td>Arithmetic evaluation</td></tr>
    <tr><td><code>${var%.ext}</code></td><td>Remove extension</td></tr>
  </table>

  <p>These tools make your scripts flexible, dynamic, and much more powerful when automating real tasks in bioinformatics and system operations.</p>
</section>
  
  <h4>üìÑ Example: <code>process_samples.sh</code></h4>
  <pre><code>#!/bin/bash

echo "Sample Report"

for sample in samples/*.txt; do
  echo "Processing $sample"
  grep "gene" "$sample" | cut -f1,2
done</code></pre>
 <h4>üìÑ Example: <code>organize.sh</code>. Here is the sample files you can use: <a href="/bbc2025v1/docs/2025/module1_basic_linux/resources/scripting.zip">scripting.zip</a></h4>
<pre><code>#!/bin/bash

# Create target folders
mkdir -p fasta fastq txt csv log other

# Move files based on extension (from current dir and known subdirectories)
mv *.fasta fasta/
mv dir1/*.fasta dir2/*.fasta dir3/*.fasta fasta/

mv *.fastq fastq/
mv dir1/*.fastq dir2/*.fastq dir3/*.fastq fastq/

mv *.txt txt/
mv dir1/*.txt dir2/*.txt dir3/*.txt txt/

mv *.csv csv/
mv dir1/*.csv dir2/*.csv dir3/*.csv csv/

mv *.log log/
mv dir1/*.log dir2/*.log dir3/*.log log/

# Move other file types
mv *.* other/
mv dir1/*.* dir2/*.* dir3/*.* other/

# Remove unnecessary (now empty) directories
rm -r dir1 dir2 dir3

# Show how many files are in each folder
echo "üìÅ File counts:"
echo "fasta:  $(ls fasta | wc -l) files"
echo "fastq:  $(ls fastq | wc -l) files"
echo "txt:    $(ls txt | wc -l) files"
echo "csv:    $(ls csv | wc -l) files"
echo "log:    $(ls log | wc -l) files"
echo "other:  $(ls other | wc -l) files"

echo "‚úÖ Files organized and extra directories removed."</code></pre>

  <p><strong>How to run:</strong></p>
  <pre><code>bash process_samples.sh</code></pre>
 <h4>üìÑ UPDATE SCRIPT Example: <code>organize.sh</code>. This uses if and loop statements</h4> 
  <pre><code>#!/bin/bash

# Define extensions and their target folders
extensions="fasta fastq txt csv log"
folders="fasta fastq txt csv log other"

# Create target folders
for folder in $folders; do
  mkdir -p "$folder"
done

# Known directories to check
dirs="dir1 dir2 dir3"

# Move files by extension from current and subdirectories
for ext in $extensions; do
  # Move from current directory
  if ls *."$ext"; then
    mv *."$ext" "$ext"/
  fi

  # Move from subdirectories
  for d in $dirs; do
    if ls "$d"/*."$ext"; then
      mv "$d"/*."$ext" "$ext"/
    fi
  done
done

# Move remaining files to "other"
for d in . $dirs; do
  if ls "$d"/*.*; then
    mv "$d"/*.* other/
  fi
done

# Remove now-empty subdirectories
for d in $dirs; do
  if [ -d "$d" ]; then
    rmdir "$d"
  fi
done

# Count files in each folder
echo "üìÅ File counts:"
for folder in $folders; do
  count=$(ls "$folder" | wc -l)
  echo "$folder: $count files"
done

echo "‚úÖ Files organized and extra directories removed."</code></pre>
  
 <h3>üß¨ Why Bash Scripting Matters in Bioinformatics</h3>
  <ul>
    <li>‚öôÔ∏è Automates repetitive analysis steps</li>
    <li>üìä Processes large text-based files (FASTA, FASTQ, GFF, VCF)</li>
    <li>üîó Integrates tools into workflows and pipelines</li>
    <li>üß™ Speeds up tasks like filtering, reformatting, and summarizing data</li>
  </ul>

  <p>üí° <strong>Tip:</strong> Start with small command combinations, then move them into scripts as you repeat them.</p>

  <p><strong>Learn more:</strong> 
    <a href="https://www.gnu.org/software/bash/manual/bash.html" target="_blank" rel="noopener noreferrer">GNU Bash Manual</a>
  </p>
			<h3>Creating or Writing a bash script</h3>
			<ol>
				<li>Create a new file with a <code>.sh</code> extension. For
					example: 
					<pre><code>nano myscript.sh</code></pre>
				</li>
				<li>Add the shebang line at the top to specify the interpreter:
					<pre><code>#!/bin/bash</code></pre>
				</li>
				<li>Write your desired commands below the shebang line. For
					example: <pre>
<code>#!/bin/bash
echo "Hello, World!"</code>
</pre>
				</li>
				<li>Save and exit the editor (in nano, press <code>Ctrl+O</code>
					to save and <code>Ctrl+X</code> to exit).
				</li>
			</ol>
			<h3>Changing File Permissions to Execute</h3>
			<p>
				Before running the script, you need to make it executable. Use the
				<code>chmod</code>
				command:
			</p>
			<pre><code>chmod +x myscript.sh</code></pre>
			<p>This command grants execute permission to the script, allowing
				it to be run as a program.</p>
			<h3>Running the Script</h3>
			<p>To execute the script, use one of the following methods:</p>
			<ul>
				<li>Run the script from the current directory: 
				<pre><code>./myscript.sh</code></pre>
				</li>
				<li>Specify the full path to the script: 
				<pre><code>/path/to/myscript.sh</code></pre>
				</li>
				<li>Use the <code>bash</code> command to run the script
					(execute permission not required in this case): 
					<pre><code>bash myscript.sh</code></pre>
				</li>
			</ul>
			<p>
				Ensure that the script is located in a directory included in your
				system's
				<code>PATH</code>
				environment variable if you wish to run it without specifying the
				path.
			</p>
		</section>

		<section id="linux-process-control">
			<h2>Linux Process Control</h2>
			<p>A process is an instance of a running program, each identified
				by a unique Process Identifier (PID). Understanding process
				management is crucial for system administration and performance
				optimization.</p>

			<h3>Viewing Processes</h3>
			<p>
				<strong>ps</strong>: Displays a snapshot of current processes.
			</p>
			<pre><code>ps aux</code></pre>
			<p>This command lists all running processes with detailed
				information.</p>

			<p>
				<strong>top</strong>: Provides a real-time, dynamic view of system
				processes.
			</p>
			<pre><code>top</code></pre>
			<p>Press 'k' to kill a process, then enter the PID.</p>

			<h3>Managing Processes</h3>
			<p>
				<strong>kill</strong>: Terminates a process by sending a signal.
			</p>
			<pre><code>kill -9 <PID></code></pre>
			<p>
				Use
				<code>-9</code>
				for a forceful termination.
			</p>

			<p>
				<strong>killall</strong>: Terminates processes by name.
			</p>
			<pre><code>killall <process_name></code></pre>
			<p>This command is useful when you know the process name but not
				the PID.</p>

			<h3>Adjusting Process Priority</h3>
			<p>
				<strong>nice</strong>: Starts a process with a specified priority.
			</p>
			<pre><code>nice -n 10 <command></code></pre>
			<p>Values range from -20 (highest priority) to 19 (lowest
				priority).</p>

			<p>
				<strong>renice</strong>: Changes the priority of an already running
				process.
			</p>
			<pre><code>renice -n 10 -p <PID></code></pre>
			<p>Adjust the priority of a process identified by its PID.</p>
			

		</section>
		
		<section id="linux-job-control">
			<h2>Linux Job Control</h2>
			<p>
				In Linux, a <strong>job</strong> refers to a set of processes, such
				as a shell pipeline and any processes descended from it, all within
				the same process group. These jobs are identified by their job
				numbers and can be managed using various shell commands.
			</p>

			<h3>Job Control Commands</h3>
			<dl>
				<dt>
					<code>jobs</code>
				</dt>
				<dd>Displays the status of jobs in the current shell session.</dd>
				<dt>
					<code>fg [JOB_SPEC]</code>
				</dt>
				<dd>Brings a background job into the foreground, allowing
					interaction. If no job specification is provided, it resumes the
					most recent job.</dd>
				<dt>
					<code>bg [JOB_SPEC]</code>
				</dt>
				<dd>Resumes a suspended job in the background, allowing the
					terminal to be used for other tasks.</dd>
				<dt>
					<code>kill [PID]</code>
				</dt>
				<dd>Terminates a process by its Process ID (PID).</dd>
				<dt>
					<code>killall [PROCESS_NAME]</code>
				</dt>
				<dd>Terminates all processes with the specified name.</dd>
			</dl>

			<h3>Managing Jobs</h3>
			<p>To manage jobs effectively:</p>
			<ul>
				<li><strong>Suspend a job:</strong> Press <code>Ctrl+Z</code>
					to suspend a foreground job.</li>
				<li><strong>Bring a job to the foreground:</strong> Use <code>fg</code>
					to resume a suspended job in the foreground.</li>
				<li><strong>Send a job to the background:</strong> Use <code>bg</code>
					to resume a suspended job in the background.</li>
				<li><strong>Terminate a job:</strong> Use <code>kill</code>
					followed by the job's PID to terminate it.</li>
			</ul>

			<h3>Example</h3>
			<p>Consider the following example where a job is created and
				managed:</p>
			<pre><code>cat file.txt | tr 'a-z' 'A-Z' > output.txt</code></pre>
			<p>
				This command creates two processes:
				<code>cat</code>
				and
				<code>tr</code>
				. To manage these processes:
			</p>
			<ul>
				<li>Check the status of jobs: <code>jobs</code></li>
				<li>Bring a background job to the foreground: <code>fg
						%1</code></li>
				<li>Send a foreground job to the background: <code>bg %1</code></li>
				<li>Terminate a job: <code>kill %1</code></li>
			</ul>

			<p>
				For more detailed information on job control in Linux, refer to the
				<a href="https://www.redhat.com/en/blog/jobs-bg-fg">Red Hat
					article on jobs, bg, and fg</a>.
			</p>
		</section>
		<section id="linux-process-job-control">
			<h2>Linux Process & Job Control Commands</h2>
			<p>Efficiently managing processes and jobs is crucial for system
				administration. Below is a summary of essential commands for
				handling processes and jobs in Linux:</p>

			<dl>
				<dt>
					<code>ps</code>
				</dt>
				<dd>
					Lists currently running processes. Use
					<code>ps aux</code>
					for a detailed view.
				</dd>

				<dt>
					<code>top</code>
				</dt>
				<dd>Provides a real-time, dynamic view of system processes and
					resource usage.</dd>

				<dt>
					<code>kill</code>
				</dt>
				<dd>
					Terminates a process by its Process ID (PID). Use
					<code>kill -9 PID</code>
					for forceful termination.
				</dd>

				<dt>
					<code>nice</code>
				</dt>
				<dd>
					Starts a process with a specified priority. Use
					<code>nice -n 10 command</code>
					to set the priority.
				</dd>

				<dt>
					<code>jobs</code>
				</dt>
				<dd>Displays the status of jobs in the current session, showing
					job numbers and their states.</dd>

				<dt>
					<code>fg</code>
				</dt>
				<dd>
					Brings a background job into the foreground. Use
					<code>fg %1</code>
					to bring job 1 to the foreground.
				</dd>

				<dt>
					<code>bg</code>
				</dt>
				<dd>
					Resumes a suspended job in the background. Use
					<code>bg %1</code>
					to resume job 1 in the background.
				</dd>

				<dt>
					<code>Ctrl+C</code>
				</dt>
				<dd>Terminates the currently running foreground process by
					sending a SIGINT signal.</dd>

				<dt>
					<code>Ctrl+Z</code>
				</dt>
				<dd>Suspends the currently running foreground process by
					sending a SIGTSTP signal, allowing it to be resumed later.</dd>
			</dl>
			
			<h3>üß™ Real-Time Process and Job Control Examples</h3>

  <p><strong>Create a background process:</strong></p>
  <pre><code>sleep 300 &</code></pre>

  <p><strong>View it with:</strong></p>
  <pre><code>ps aux | grep sleep
top</code></pre>

  <p><strong>Suspend with Ctrl+Z, then:</strong></p>
  <pre><code>jobs
bg %1
fg %1
kill %1</code></pre>

  <p><strong>Adjust priority:</strong></p>
  <pre><code>nice -n 10 sleep 300 &
renice -n -5 -p &lt;PID&gt;</code></pre>

  <h4>üßπ Reminder: Clean Up</h4>
  <p>To safely clean up background processes created for this demo:</p>
  <pre><code>killall sleep
jobs
</code></pre>
			

			<p>
				For more detailed information and examples on managing jobs in
				Linux, refer to Jesin's Blog on job management in Linux: <a
					href="https://websistent.com/how-to-manage-jobs-in-linux-fg-bg-kill-ctrlz/">How
					to manage jobs in Linux - fg bg kill Ctrl+Z</a>
			</p>
		</section>

		<section id="shell-expansion">
			<h2>Shell Expansion</h2>
			<p>In the Bash shell, expansion refers to the process by which
				the shell interprets and transforms input before executing commands.
				Understanding these expansions is crucial for effective shell
				scripting and command-line usage.</p>
			<h3>Types of Shell Expansion</h3>
			<ol>
				<li><strong>Brace Expansion:</strong> Generates arbitrary
					strings. For example: <pre><code>echo file{1..3}.txt</code></pre> Output: 
					<pre><code>file1.txt file2.txt file3.txt</code></pre>
					</li>
				<li><strong>Tilde Expansion:</strong> Replaces the tilde (~)
					with the path to the home directory. For example: 
					<pre><code>cd ~</code></pre> 
					Changes to the current user's home directory.</li>
				<li><strong>Parameter and Variable Expansion:</strong> Replaces
					variables with their values. For example: 
					<pre><code>echo $HOME</code></pre> 
					Outputs the path of the home directory.</li>
				<li><strong>Command Substitution:</strong> Replaces a command
					with its output. For example: 
					<pre><code>echo "Today is $(date)"</code></pre> 
					Might output:
					 <pre><code>Today is Thu May 8 14:58:57 PHT 2025</code></pre>
					 </li>
				<li><strong>Arithmetic Expansion:</strong> Evaluates arithmetic
					expressions. For example: 
					<pre><code>echo $((3 + 2))</code></pre> 
					Outputs: 
					<pre><code>5</code></pre>
					</li>
				<li><strong>Word Splitting:</strong> Splits the result of
					expansions into separate words based on the Internal Field
					Separator (IFS). For example: 
					<pre><code>list="one two three"
    for word in $list; do
      echo "$word"
    done</code></pre> Outputs: 
    <pre>
<code>one
two
three</code></pre></li>
				<li><strong>Filename Expansion (Globbing):</strong> Expands
					wildcard patterns to match filenames. For example: 
					<pre><code>ls *.txt</code></pre> 
					Lists all files ending with .txt in the current directory.</li>
			</ol>
			<h3>Order of Expansion</h3>
			<p>The shell performs expansions in the following order:</p>
			<ol>
				<li>Brace Expansion</li>
				<li>Tilde Expansion</li>
				<li>Parameter and Variable Expansion</li>
				<li>Command Substitution</li>
				<li>Arithmetic Expansion</li>
				<li>Word Splitting</li>
				<li>Filename Expansion</li>
			</ol>
			<p>Understanding this order is essential, as the output of one
				expansion can be the input for the next.</p>
		</section>

		

		<section id="environment-variables">
			<h2>Environment Variables</h2>
			<p>Environment variables are key-value pairs that influence the
				behavior of processes and applications on a system. They store
				configuration settings, such as file locations or user preferences,
				and facilitate communication between different parts of the
				operating system.</p>
			<h3>Viewing Environment Variables</h3>
			<ul>
				<li>Display all environment variables: 
				<pre><code>printenv</code></pre>
				</li>
				<li>Display a specific variable: 
				<pre><code>echo $VARIABLE_NAME</code></pre>
				</li>
			</ul>
			<h3>Setting Environment Variables</h3>
			<ul>
				<li>Temporarily set a variable for the current session: 
				<pre><code>export VARIABLE_NAME="value"</code></pre>
				</li>
				<li>To make a variable available to child processes: 
				<pre><code>export VARIABLE_NAME="value"</code></pre>
				</li>
			</ul>
			<h3>Unsetting Environment Variables</h3>
			<ul>
				<li>Remove a variable from the current session: 
				<pre><code>unset VARIABLE_NAME</code></pre>
				</li>
			</ul>
			<h3>Persistent Environment Variables</h3>
			<p>To retain environment variables across sessions, define them
				in configuration files:</p>
			<ul>
				<li>User-specific variables (affect only the current user):
					<ul>
						<li><code>~/.bashrc</code>: Loaded for interactive non-login
							shells.</li>
						<li><code>~/.bash_profile</code>: Loaded for login shells.</li>
					</ul> Add the export statement to one of these files: 
					<pre><code>export VARIABLE_NAME="value"</code></pre> 
					Then, apply the changes: 
					<pre><code>source ~/.bashrc</code></pre>
				</li>
				<li>System-wide variables (affect all users):
					<ul>
						<li><code>/etc/environment</code>: Suitable for simple
							variable assignments.</li>
						<li><code>/etc/profile</code> or scripts in <code>/etc/profile.d/</code>:
							Used for more complex configurations.</li>
					</ul> Example of adding a variable to <code>/etc/environment</code>: 
					<pre>
						<code>sudo nano /etc/environment 
# Add the line:
VARIABLE_NAME="value"</code>
</pre> After editing, apply the changes: 
					<pre><code>source /etc/environment</code></pre>
				</li>
			</ul>
			<h3>Common Environment Variables</h3>
			<ul>
				<li><code>PATH</code>: Directories where the system looks for
					executable files.</li>
				<li><code>HOME</code>: The current user's home directory.</li>
				<li><code>LANG</code>: Defines the system's language and locale
					settings.</li>
				<li><code>USER</code>: The name of the current user.</li>
			</ul>
			<h3>Best Practices</h3>
			<ul>
				<li>Use clear and descriptive names for custom environment
					variables.</li>
				<li>Be cautious when modifying system-wide configuration files;
					incorrect settings can affect all users.</li>
				<li>Always back up configuration files before making changes.</li>
			</ul>
		</section>
		<section id="bashrc-bash_profile">
			<h2>
				Shell Configuration Files:
				<code>.bashrc</code>
				and
				<code>.bash_profile</code>
			</h2>
			<p>
				In the Bash shell, configuration files like
				<code>.bashrc</code>
				and
				<code>.bash_profile</code>
				are used to set up the environment and customize shell behavior.
				Understanding the differences between these files is essential for
				effective shell configuration.
			</p>
			<h3>
				<code>.bashrc</code>
			</h3>
			<ul>
				<li><strong>Purpose:</strong> Configures the shell for
					interactive non-login sessions.</li>
				<li><strong>Execution:</strong> Automatically executed when a
					new terminal window is opened or when a new Bash shell is started
					without logging in.</li>
				<li><strong>Common Uses:</strong>
					<ul>
						<li>Defining aliases (e.g., <code>alias ll='ls -la'</code>).
						</li>
						<li>Setting shell options and functions.</li>
						<li>Customizing the shell prompt (<code>PS1</code>).
						</li>
						<li>Configuring shell history behavior.</li>
					</ul></li>
			</ul>
			<h3>
				<code>.bash_profile</code>
			</h3>
			<ul>
				<li><strong>Purpose:</strong> Configures the shell for
					interactive login sessions.</li>
				<li><strong>Execution:</strong> Automatically executed when
					logging into the system via console, SSH, or when starting a login
					shell.</li>
				<li><strong>Common Uses:</strong>
					<ul>
						<li>Setting environment variables (e.g., <code>PATH</code>, <code>LANG</code>).
						</li>
						<li>Starting user-specific services or applications.</li>
						<li>Ensuring that <code>.bashrc</code> is sourced for login
							shells.
						</li>
					</ul></li>
			</ul>
			<h3>
				Best Practice: Source
				<code>.bashrc</code>
				from
				<code>.bash_profile</code>
			</h3>
			<p>
				To maintain consistency across login and non-login shells, it's
				common to source
				<code>.bashrc</code>
				from within
				<code>.bash_profile</code>
				:
			</p>
			<pre>
<code>if [ -f ~/.bashrc ]; then
      . ~/.bashrc
fi</code>
			</pre>
			<p>
				This ensures that the configurations in
				<code>.bashrc</code>
				are applied in all interactive sessions.
			</p>
			<h3>
				Exercise: Inspect Your
				<code>.bashrc</code>
				File
			</h3>
			<p>
				To view your current
				<code>.bashrc</code>
				configurations, use the following command:
			</p>
			<pre><code>less ~/.bashrc</code></pre>
			<p>
				This will display the contents of your
				<code>.bashrc</code>
				file, allowing you to review and understand the customizations
				applied to your shell environment.
			</p>
		</section>
		<section id="linux-tips">
			<h2>Essential Linux Tips</h2>
			<h3>
				Understanding the
				<code>$PATH</code>
				Variable
			</h3>
			<p>
				The
				<code>$PATH</code>
				variable is a colon-delimited list of directories that the shell
				searches through when you enter a command. The directories are
				checked in the order they're listed, so if multiple directories
				contain executables with the same name, the first one found is
				executed :contentReference[oaicite:0]{index=0}.
			</p>
			<h3>Viewing Hidden Files</h3>
			<p>
				To view hidden files (those starting with a dot, e.g.,
				<code>.bashrc</code>
				), use the
				<code>-a</code>
				option with the
				<code>ls</code>
				command:
			</p>
			<pre><code>ls -a</code></pre>
			<p>This will display all files, including hidden ones, in the
				current directory.</p>
			<h3>Handling Filenames with Spaces</h3>
			<p>Filenames with spaces can be tricky in the terminal. To handle
				them:</p>
			<ul>
				<li>Enclose the filename in quotes: 
				<pre><code>cd "My Folder"</code></pre>
				</li>
				<li>Escape each space with a backslash: 
				<pre><code>cd My\ Folder</code></pre>
				</li>
			</ul>
			<p>Alternatively, you can use tab completion to automatically
				escape spaces.</p>
			<h3>Clearing the Terminal Screen</h3>
			<p>
				To clear the terminal screen, you can use the
				<code>clear</code>
				command:
			</p>
			<pre><code>clear</code></pre>
			<p>For a more thorough reset, use:</p>
			<pre><code>reset</code></pre>
			<p>This command reinitializes the terminal, clearing the screen
				and resetting settings :contentReference[oaicite:1]{index=1}.</p>
			<h3>
				Using
				<code>sudo</code>
				for Elevated Privileges
			</h3>
			<p>
				The
				<code>sudo</code>
				command allows you to run commands with elevated privileges,
				typically as the root user. This is useful for administrative tasks
				like installing software or modifying system configurations
				:contentReference[oaicite:2]{index=2}.
			</p>
			<p>
				To use
				<code>sudo</code>
				, prefix your command with it:
			</p>
			<pre><code>sudo command</code></pre>
			<p>You'll be prompted to enter your password to confirm your
				identity.</p>
		</section>
		
		<section>
  <h2>Popup Quiz: Build a Gene Expression Matrix</h2>

  <h3>üìù Use Case:</h3>
  <p>
    You are given 6 expression data files named:
    <code>sample1.tab, sample2.tab, ..., sample6.tab</code><br>
    Download it <a href="/bbc2025v1/docs/2025/module1_basic_linux/resources/sample.zip">here</a><br>
    Each file contains <strong>two columns</strong>:<br>
    - <strong>Column 1</strong>: Gene names<br>
    - <strong>Column 2</strong>: Expression values for that sample
  </p>
  <p>
    Your goal is to write a <strong>Bash script</strong> that:
  </p>
  <ol>
    <li>Extracts gene names from <code>sample1.tab</code></li>
    <li>Extracts expression values (column 2) from all 6 files</li>
    <li>Combines all values side-by-side into a single file</li>
    <li>Names the final output as: <code>&lt;yourlastname&gt;_activity4.txt</code><br>
      Example: If your last name is <code>Garcia</code>, output file should be <code>Garcia_activity4.txt</code>
    </li>
  </ol>

    <h3>üí°HINTS [You may choose not to use these hints and are encouraged to solve the problem using your own approach.]</h3>
  <ul>
    <li>Use <code>awk '{print $1}'</code> to get the first column (gene names)</li>
    <li>Use <code>for ((i=1; i&lt;=6; i++))</code> to iterate over files</li>
    <li>Use <code>sample${i}.tab</code> for dynamic filenames</li>
    <li>Use <code>paste</code> to merge files side by side</li>
 
  </ul>

  <h3>‚úÖ Expected Output File Format (tab-delimited):</h3>
	  <img src="resources/result.png" alt="Linux Filesystem Structure" style="max-width:100%; height:auto; border:1px solid #ccc; border-radius:8px;">
</section>

<section id="popupquiz3">
  <h2>Popup Quiz 3</h2>

  <h3>1. Show all samples for the variety ‚ÄúNipponbare‚Äù</h3>
  <p><strong>Command:</strong></p>
  <pre><code>grep "Nipponbare" samples.tsv</code></pre>
  <p><strong>Explanation:</strong> This command looks through the file and shows all lines that mention ‚ÄúNipponbare‚Äù.</p>

  <h3>2. Count how many samples are under the "Stress" condition</h3>
  <p><strong>Command:</strong></p>
  <pre><code>grep "Stress" samples.tsv | wc -l</code></pre>
  <p><strong>Explanation:</strong> 
    <ul>
      <li><code>grep "Stress"</code> finds all lines that contain the word "Stress".</li>
      <li><code>wc -l</code> counts how many lines were found.</li>
      <li><strong>The pipe <code>|</code> connects the two commands</strong> so that the result of <code>grep</code> is passed into <code>wc -l</code>.</li>
    </ul>
  </p>

  <h3>3. Show SampleID, Tissue, Variety, and Replicate for samples with Replicate 2</h3>
  <p><strong>Command:</strong></p>
  <pre><code>awk '$6 == "2" {print $1, $3, $5, $6}' samples.tsv</code></pre>
  <p><strong>Explanation:</strong> This shows only the rows where the 6th column (Replicate) is ‚Äú2‚Äù. It prints just the needed columns: Sample ID (column 1), Tissue (3), Variety (5), and Replicate (6).</p>

  <h3>4. Save only SampleID, Organism, and Variety into a new file</h3>
  <p><strong>Command:</strong></p>
  <pre><code>cut -f1,2,5 samples.tsv > newSamples.tsv</code></pre>
  <p><strong>Explanation:</strong> This picks columns 1 (SampleID), 2 (Organism), and 5 (Variety) from the file and saves them into a new file called <code>newSamples.tsv</code>.</p>

  <h3>5. Turn commas into new lines and rename gene codes</h3>
  <p><strong>Command:</strong></p>
  <pre><code>cat genes.txt | tr ',' '\n' | sed 's/LOC_Os/Gene/g' > clean_genes.txt</code></pre>
  <p><strong>Explanation:</strong> 
    <ul>
      <li><code>cat genes.txt</code> reads the file.</li>
      <li><code>tr ',' '\n'</code> changes every comma into a new line.</li>
      <li><code>sed 's/LOC_Os/Gene/g'</code> replaces all "LOC_Os" with "Gene".</li>
      <li><strong>The pipe <code>|</code></strong> is used to pass the result of one command to the next. This creates a chain where the output of one command becomes the input of the next.</li>
      <li><code>></code> saves the final cleaned result into a file called <code>clean_genes.txt</code>.</li>
    </ul>
  </p>
</section>



		
		
		</br> </br> </br>
	</main>


</body>
</html>
