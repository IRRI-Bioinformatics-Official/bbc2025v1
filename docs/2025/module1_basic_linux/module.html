<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">

<title>Basic Linux Course</title>
<style>
body {
	font-family: Arial, sans-serif;
	margin: 0;
	padding: 0;
	line-height: 1.6;
	display: flex;
	margin-bottom: 100px;
}

html, body {
	height: 100%;
	overflow: auto;
	overscroll-behavior: contain;
}

/* Floating Table of Contents */
#toc {
	position: fixed;
	top: 0px;
	left: 20px;
	width: 200px;
	background-color: #f8f9fa;
	padding: 1rem;
	border-radius: 8px;
	box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
	z-index: 1000;
}

#toc h2 {
	font-size: 1.2rem;
	margin-bottom: 1rem;
}

#toc ul {
	list-style-type: none;
	font-size: .9rem;
	padding: 0;
}

#toc ul li {
	margin: 0.5rem 0;
}

#toc ul li a {
	text-decoration: none;
	color: #007bff;
}

#toc ul li a:hover {
	text-decoration: underline;
}
/* Main content styling */
main {
	margin-left: 240px; /* Adjusted for TOC width */
	padding: 2rem;
	flex-grow: 1;
}

h1, h2 {
	color: #2c3e50;
}

section {
	margin-bottom: 2rem;
	max-width: 800px;
	padding: 20px;
	background-color: white;
	border-radius: 8px;
	box-shadow: 0 4px 8px rgba(0, 0, 0, 0.1);
}

pre, code {
	background-color: #ededed;
	color: #312f2f;
	padding: 5px 10px;
	border-radius: 4px;
	font-size: .9em;
	font-family: Consolas, monospace;
	overflow-x: auto;
}

code {
	font-size: 1em;
	background-color: #ededed;
	padding: 2px 5px;
	border-radius: 3px;
}

.codeCopy {
	width: 100%;
	display: block;
}

ul {
	list-style-type: none;
	padding-left: 20px;
}

ul li {
	margin-bottom: 10px;
}

ol {
	padding-left: 20px;
}

li {
	margin-bottom: 10px;
}

strong {
	color: #2c3e50;
}

/* Responsive adjustments */
@media ( max-width : 768px) {
	body {
		flex-direction: column;
	}
	#toc {
		position: static;
		width: auto;
		box-shadow: none;
		margin: 1rem;
	}
	main {
		margin-left: 0;
		padding: 1rem;
	}
}

@media ( max-width : 480px) {
	#toc h2 {
		font-size: 1rem;
	}
	#toc ul li {
		font-size: 0.85rem;
	}
	section {
		padding: 1rem;
	}
	pre, code {
		font-size: 0.85em;
	}
}

.output-box {
	border: 1px solid #ccc;
	padding: 10px;
	margin: 10px;
	width: 300px;
	overflow-x: auto;
}

#copy-btn {
	margin-top: 10px;
	cursor: pointer;
	position: absolute;
	top: 10px; /* Position the button at the top */
	right: 10px; /* Position the button at the right */
	border: 0px;
	background: #369136;
	padding: 5px;
	border-radius: 5px;
	color: white;
	background: #369136;
	padding: 5px;
	border-radius: 5px;
	padding: 5px;
	border-radius: 5px;
	color: white;
	background: #369136;
	padding: 5px;
	border-radius: 5px;
	padding: 5px;
	border-radius: 5px;
	color: white;
	background: #369136;
	padding: 5px;
	border-radius: 5px;
	padding: 5px;
	border-radius: 5px;
	color: white;
	background: #369136;
	padding: 5px;
	border-radius: 5px;
	padding: 5px;
	background: #369136;
	padding: 5px;
	border-radius: 5px;
	padding: 5px;
	border-radius: 5px;
	color: white;
	background: #369136;
	padding: 5px;
	border-radius: 5px;
	padding: 5px;
	padding: 5px;
	border-radius: 5px;
	padding: 5px;
	border-radius: 5px;
	color: white;
	background: #369136;
	padding: 5px;
	border-radius: 5px;
	padding: 5px;
	border-radius: 5px;
	padding: 5px;
	border-radius: 5px;
	color: white;
	background: #369136;
	padding: 5px;
	border-radius: 5px;
	padding: 5px;
	padding: 5px;
	border-radius: 5px;
	color: white;
	background: #369136;
	padding: 5px;
	border-radius: 5px;
	padding: 5px;
	border-radius: 5px;
	color: white;
	background: #369136;
	padding: 5px;
	border-radius: 5px;
	padding: 5px;
	color: white;
	background: #369136;
	padding: 5px;
	border-radius: 5px;
	padding: 5px;
	background: #369136;
	padding: 5px;
	border-radius: 5px;
	padding: 5px;
	padding: 5px;
	border-radius: 5px;
	padding: 5px;
	border-radius: 5px;
	padding: 5px;
	padding: 5px;
}

#copy-btn:hover {
	background-color: #45a049;
}

.code_div {
	width: 100%;
	margin-top: 10px;
	margin-bottom: 10px;
	padding: 5px;
}
</style>
<script>
  document.addEventListener("DOMContentLoaded", function () {
    const toc = document.getElementById("toc");
    const toggleBtn = document.getElementById("toggleToc");

    function checkScreenWidth() {
      if (window.innerWidth <= 768) {
        toggleBtn.style.display = 'block';
        toc.style.display = 'none';
      } else {
        toggleBtn.style.display = 'none';
        toc.style.display = 'block';
      }
    }

    toggleBtn.addEventListener("click", () => {
      toc.style.display = (toc.style.display === 'none') ? 'block' : 'none';
    });

    window.addEventListener("resize", checkScreenWidth);
    checkScreenWidth();
    
    const copyButtons = document.querySelectorAll('.copy-btn');
    
    copyButtons.forEach(button => {
        button.addEventListener("click", function() {
            // Find the associated command text (inside the <code> tag)
            const commandText = button.previousElementSibling.innerText;

            // Create a temporary input to copy the command text
            const tempInput = document.createElement("input");
            tempInput.value = commandText;
            document.body.appendChild(tempInput);

            // Select the text and copy it
            tempInput.select();
            document.execCommand("copy");

            // Remove the temporary input
            document.body.removeChild(tempInput);

            button.textContent = "Copied";
        });
    });
  });
</script>



</head>
<body>
	<script>
    document.addEventListener("DOMContentLoaded", function () {
      const tocLinks = document.querySelectorAll('#toc a[data-target]');
      tocLinks.forEach(link => {
        link.addEventListener('click', function (e) {
          e.preventDefault();
          const targetId = this.getAttribute('data-target');
          const targetElement = document.getElementById(targetId);
          if (targetElement) {
            targetElement.scrollIntoView({ behavior: 'smooth', block: 'start' });
          }
        });
      });
    });
  </script>
	<!-- Floating Table of Contents -->
	<div id="toc">
		<h2>Table of Contents:</h2>
		<ul>
			<li><a href="#" data-target="overview">i. Overview</a></li>
			<li><a href="#" data-target="os">I. Operating Systems</a></li>
			<li><a href="#" data-target="why-linux">II. Linux for
					Bioinformatics</a></li>
			<li><a href="#" data-target="filesystem-structure">III.
					Filesystem Structure and Layout</a></li>
			<li><a href="#" data-target="intro-linux-commands">IV. Linux
					Commands</a></li>
			<li><a href="#" data-target="filesystem">IV. Filesystem
					Navigation</a></li>
			<li><a href="#" data-target="filemanagement">V. File
					Management</a></li>
			<li><a href="#" data-target="linkx-linux">VI. Hard and Soft
					Links</a></li>
			<li><a href="#" data-target="viewing">VII. Viewing Files</a></li>
			<li><a href="#" data-target="compressed">VIII. Handling
					Compressed Files</a></li>
			<li><a href="#" data-target="bioinformatics-ile-formats">IX.
					Bioinformatics File Formats</a></li>
			<li><a href="#" data-target="pattern-matching">X. Pattern
					Matching in Bash</a></li>
			<li><a href="#" data-target="text-processing-tools">XI. Text
					Processing Tools</a></li>
			<li><a href="#" data-target="bash-bioinformatics">XII. Bash
					Manipulation</a></li>
			<li><a href="#" data-target="io-redirection">XIII. I/O
					Redirection</a></li>
			<li><a href="#" data-target="linux-process-control">XIV.
					Process Control</a></li>
			<li><a href="#" data-target="linux-job-control">XIV. Job
					Control</a></li>
			<li><a href="#" data-target="shell-expansion">XV. Shell
					Expansion</a></li>
			<li><a href="#" data-target="shell-scripting">XVI. Shell
					Scripting</a></li>
			<li><a href="#" data-target="environment-variables">XVII.
					Environment Variable</a></li>
			<li><a href="#" data-target="bashrc-bash_profile">XVIII.
					Shell Configuration Files</a></li>
			<li><a href="#" data-target="linux-tips">XIX. Linux Tips</a></li>
			<li><a href="#" data-target="quiz">XX. Activity</a></li>

			<li><a href="main_c.html" target="blank">IX. Cheat Sheet</a></li>
		</ul>
	</div>


	<!-- Main Content -->
	<main style="margin-bottom: 100px; margin-top: 20px;">
		<button id="toggleToc" style="display: none;">‚ò∞ Table of
			Contents</button>

		<section id="overview">
			<h2>üß≠ Training Overview: Linux Basics, Filesystem, and Shell
				Navigation</h2>

			<h3>üéØ Topic</h3>
			<p>Linux Basics, Filesystem, and Shell Navigation</p>

			<h3>üë• Target Audience</h3>
			<p>Beginners in bioinformatics ‚Äî no prior Linux experience
				required.</p>

			<h3>üèÅ Goal</h3>
			<p>Help participants become comfortable using the Linux terminal
				and executing essential file and folder commands commonly used in
				bioinformatics workflows.</p>
		</section>

		<section id="os">
			<h2>Understanding Operating Systems for Bioinformatics</h2>
			<p>
				When working with bioinformatics tools, it's essential to understand
				the differences between operating systems (OS) like <strong>Windows</strong>,
				<strong>Linux</strong>, and <strong>macOS</strong>, as well as how
				to bridge the gap between them using tools like <strong>WSL
					(Windows Subsystem for Linux)</strong>.
			</p>

			<h3>1. Windows vs. Linux vs. macOS</h3>
			<ul>
				<li><strong>Windows</strong> is a popular OS for general use
					and is often used in corporate environments. While it has GUI-based
					tools, it can be limiting when working with command-line-heavy
					bioinformatics workflows. Many bioinformatics tools are not
					natively supported on Windows, requiring workarounds like WSL or
					virtual machines.</li>
				<li><strong>Linux</strong> is the preferred OS for
					bioinformatics because it offers superior performance, stability,
					and extensive command-line tools designed specifically for
					computational tasks and data analysis. Most bioinformatics software
					is optimized for Linux.</li>
				<li><strong>macOS</strong> is similar to Linux in terms of
					underlying architecture (both are Unix-based), so many
					bioinformatics tools that run on Linux can also run on macOS. It's
					often preferred by researchers who need a balance of ease of use
					(macOS GUI) and command-line functionality. It offers strong
					support for development environments and bioinformatics software,
					though some specialized Linux tools might require additional setup.</li>
			</ul>

			<h3>2. Windows Subsystem for Linux (WSL)</h3>
			<ul>
				<li><strong>WSL</strong> allows Windows users to run a Linux
					environment directly on top of Windows without the need for
					dual-booting or using virtual machines.</li>
				<li>WSL provides a full Linux kernel, enabling users to install
					and run popular bioinformatics tools that are typically only
					available on Linux.</li>
				<li><strong>Advantages of WSL:</strong></li>
				<ul>
					<li>Easy access to both Windows and Linux tools in one
						environment.</li>
					<li>Ideal for Windows users who need to run Linux tools
						without switching OS.</li>
					<li>Access to the Linux file system and native Linux utilities
						directly from Windows.</li>
				</ul>
				<li><strong>Limitations of WSL:</strong></li>
				<ul>
					<li>Some high-performance tools might not run as efficiently
						as on a full Linux system.</li>
					<li>While WSL 2 supports a full Linux kernel, it still
						operates within Windows, which could affect performance with very
						large datasets or computationally intensive tasks.</li>
				</ul>
			</ul>

			<h3>3. Choosing the Right OS for Your Work</h3>
			<ul>
				<li><strong>Linux</strong> is the best option for
					bioinformatics work, as it provides the best performance,
					efficiency, and native support for bioinformatics tools.</li>
				<li><strong>macOS</strong> is a good alternative if you need
					the Unix environment but prefer a more user-friendly GUI. It‚Äôs
					compatible with most bioinformatics tools and is widely used by
					researchers who prefer working with a Mac.</li>
				<li><strong>Windows</strong> is less ideal for bioinformatics
					but can be used effectively with tools like WSL to run Linux-based
					tools without switching OSs.</li>
				<li>If you‚Äôre a Windows user and need Linux tools, <strong>WSL</strong>
					is a great option to get the Linux environment without leaving
					Windows.
				</li>
				<li>For macOS users, using a native Unix-based environment
					makes it easy to run bioinformatics tools, but certain specialized
					Linux tools might require additional setup or a virtual machine.</li>
			</ul>
		</section>

		<section id="why-linux">
			<h2>Why Linux is Important in Bioinformatics</h2>
			<ul>
				<li><strong>Most Bioinformatics Tools Are Built for
						Linux:</strong> Many tools used in bioinformatics, like those for gene
					analysis and sequencing, work best on Linux systems.</li>
				<li><strong>Free and Open Source:</strong> Linux is free to
					use, and bioinformatics software is often open-source, meaning
					anyone can use, modify, and share it.</li>
				<li><strong>Handles Large Data Efficiently:</strong>
					Bioinformatics involves working with huge data files (like genome
					data). Linux is good at managing and processing large amounts of
					data quickly.</li>
				<li><strong>Works Well with High-Performance
						Computers:</strong> Many research labs use powerful Linux-based computers
					(called clusters) to analyze data faster.</li>
				<li><strong>Tons of Useful Tools:</strong> Linux has many
					built-in tools that make it easy to work with large data files,
					such as sorting, searching, and filtering information.</li>
			</ul>
		</section>
		<section id="linux-better">
			<h2>Why Linux is Better Than GUI (Graphical User Interface)
				Tools</h2>
			<ul>
				<li><strong>Faster and More Efficient:</strong> Linux tools are
					lightweight, meaning they use less memory and run faster compared
					to GUI-based tools.</li>
				<li><strong>Automation:</strong> You can write simple scripts
					to automate repetitive tasks, saving you time when working with big
					datasets.</li>
				<li><strong>Works Well with Large Datasets:</strong> Linux
					tools can handle large files without crashing, unlike some GUI
					tools that may struggle with big data.</li>
				<li><strong>Remote Access:</strong> You can easily access and
					run tasks on remote computers or servers using Linux, which is
					especially useful for bioinformatics work.</li>
				<li><strong>Customizable:</strong> You can personalize your
					Linux setup to make it work just the way you want, allowing you to
					create custom workflows.</li>
				<li><strong>Can Process Data Faster with Multiple
						Processors:</strong> Linux supports running tasks on multiple processors at
					once, which speeds up data analysis, especially for big
					bioinformatics jobs.</li>
			</ul>

			<h2>In Short:</h2>
			<p>Linux is fast, efficient, and free, making it ideal for
				bioinformatics work. It lets you process large amounts of data
				quickly, run tools from anywhere, and automate repetitive
				tasks‚Äîadvantages that GUI tools can‚Äôt always match.</p>
		</section>
		<section id="filesystem-structure">
			<h2>üìÅ Filesystem Structure and Layout</h2>
			<p>
				The Linux filesystem is organized as a single directory tree
				starting from the root directory
				<code>/</code>
				. Understanding this layout helps you navigate and find your files
				efficiently.
			</p>

			<ul>
				<li><code>/</code> ‚Äî The root directory, the top-level folder
					of the entire system.</li>
				<li><code>/home</code> ‚Äî Contains user home directories, where
					personal files and settings are stored (e.g., <code>/home/username</code>).</li>
			</ul>

			<p>
				In bioinformatics, most of your work will happen inside your home
				directory under
				<code>/home/username</code>
				, where you can create and organize project files safely.
			</p>
		</section>



		<section id="intro-linux-commands">
			<h2>üîß Introduction to Linux Commands</h2>
			<p>Linux commands are typed instructions entered into the
				terminal to interact with the operating system. These commands allow
				users to manage files, run programs, inspect data, and automate
				tasks ‚Äî making them especially powerful for bioinformatics and
				scientific computing.</p>

			<h3>üí° Why Learn Linux Commands?</h3>
			<ul>
				<li>Many bioinformatics tools are designed to run on Linux.</li>
				<li>Command-line tools are faster and more efficient for
					processing large datasets.</li>
				<li>Automation is easier using scripts and command
					combinations.</li>
				<li>Remote servers and high-performance clusters often run on
					Linux.</li>
			</ul>

			<h3>üñ•Ô∏è What is the Terminal?</h3>
			<p>The terminal (also called the shell or command line) is a
				text-based interface to the Linux operating system. Instead of
				clicking buttons, you type commands to get things done.</p>
			<h4>üñ•Ô∏è Terminal Access: WSL, macOS Terminal, and Linux Shell</h4>
			<p>The terminal is a text-based interface used to interact with
				the computer‚Äôs operating system. In bioinformatics, it‚Äôs a powerful
				tool for working with data and automating tasks. Here's how to
				access it on different systems:</p>

			<h5>ü™ü Windows ‚Äì WSL (Windows Subsystem for Linux)</h5>
			<ul>
				<li>WSL allows you to run a Linux environment directly on
					Windows without using a virtual machine.</li>
				<li>To open WSL: Press <code>Windows</code> + <code>R</code>,
					type <code>wsl</code>, and hit Enter.
				</li>
				<li>You can also use <strong>Windows Terminal</strong> and
					select a Linux distribution (e.g., Ubuntu).
				</li>
			</ul>

			<h5>üçé macOS ‚Äì Terminal App</h5>
			<ul>
				<li>macOS is based on Unix, so you can use the terminal just
					like Linux.</li>
				<li>To open Terminal: Press <code>Cmd</code> + <code>Space</code>,
					type <code>Terminal</code>, and press Enter.
				</li>
				<li>The macOS terminal supports most common Linux commands.</li>
			</ul>

			<h5>üêß Linux ‚Äì Native Shell</h5>
			<ul>
				<li>Linux systems come with a built-in terminal (usually Bash).</li>
				<li>To open: Look for ‚ÄúTerminal‚Äù in your application menu or
					press <code>Ctrl</code> + <code>Alt</code> + <code>T</code>.
				</li>
				<li>Linux offers full access to all features and commands
					needed in bioinformatics.</li>
			</ul>


			<h3>üìò Basic Command Syntax</h3>
			<p>Most Linux commands follow a simple structure:</p>
			<pre>
    <code>[command] [options] [arguments]</code>
  </pre>
			<p>
				<strong>Example:</strong>
			</p>
			<pre>
    <code>ls -l /home/user</code>
  </pre>
			<p>
				This runs the
				<code>ls</code>
				command (list files), with the
				<code>-l</code>
				option (long format), on the folder
				<code>/home/user</code>
				.
			</p>

			<h3>üß† Tips for Beginners</h3>
			<ul>
				<li>Use the <code>man</code> command to read the manual for any
					command (e.g., <code>man ls</code>).
				</li>
				<li>Use <code>Tab</code> to auto-complete filenames and command
					names.
				</li>
				<li>Use the <code>up arrow</code> to recall previous commands.
				</li>
				<li>Always double-check before running destructive commands
					like <code>rm</code>.
				</li>
			</ul>

			<p>
				üëâ <strong>Tip:</strong> All platforms let you practice the same
				commands. The behavior is almost identical across WSL, macOS, and
				Linux.
			</p>

			<p>In the next sections, you'll learn how to navigate the
				filesystem, manage files, and inspect data using essential Linux
				commands.</p>
		</section>


		<section id="filesystem">
			<h2>Filesystem Navigation in Linux (via WSL, Linux, or macOS)</h2>
			<p>Understanding how to navigate the file system is essential for
				working in the Linux terminal. Let‚Äôs go over the fundamental
				commands used for navigation.</p>

			<h3>1. Key Commands</h3>
			<ul>
				<li><strong> Print Working Directory: </strong> This command
					shows the <strong>current directory</strong> you are in.

					<div class="code_div">
						<code>pwd</code>
						<button class="copy-btn">Copy</button>
					</div> Example output: <code>/home/user/Documents</code></li>

				<li><strong>List:</strong> This command lists all files and
					directories in the <strong>current directory</strong>.
					<div class="code_div">
						<code>ls</code>
						<button class="copy-btn">Copy</button>
					</div> Example output: <code>Documents Pictures Downloads Music</code> <br />
					<ul>
						<li>Use
						<li>Use
							<div class="code_div">
								<code>ls -a</code>
								<button class="copy-btn">Copy</button>
							</div> to show hidden files (files starting with a dot).

						</li>
					</ul></li>

				<li><strong>Change Directory:</strong> This command allows you
					to <strong>move into a different directory</strong>. <code>cd
						Documents</code> (if it exists in the current directory).
					<ul>
						<li>To go up one level, use <code>cd Documents</code>
						</li>
					</ul></li>
			</ul>

			<h3>2. Absolute vs. Relative Paths</h3>
			<p>
				There are two types of paths used for navigation in Linux: <strong>absolute
					paths</strong> and <strong>relative paths</strong>.
			</p>
			<ul>
				<li><strong>Absolute Path:</strong> This is the full path to a
					file or directory, starting from the root directory <code>/</code>
					Example output: <code>/home/user/Documents</code> it is a <strong>complete
						reference</strong> to the file or directory location.</li>

				<li><strong>Relative Path:</strong> This refers to a location <strong>relative
						to the current directory</strong>. <code>cd Documents</code> If you're
					currently in the <code>/home/user/</code> directory, this will take
					you to <code>/home/user/Documents</code>.
					<ul>
						<li>Use <code>cd ..</code> to move to the parent directory.
						</li>
					</ul></li>
			</ul>

			<h3>3. Example Walkthrough</h3>
			<p>Let‚Äôs assume your file structure looks like this:</p>
			<pre>
				<code>
/home/user/
  ‚îú‚îÄ‚îÄ Documents/
  ‚îú‚îÄ‚îÄ Music/
  ‚îî‚îÄ‚îÄ Pictures/
    </code>
			</pre>

			<ul>
				<li><strong><code>pwd</code></strong> (Print Working
					Directory): If you're currently in the <code>/home/user/</code>
					directory, typing <code>pwd</code> will display: <code>/home/user</code>
				</li>

				<li><strong><code>ls</code></strong> (List Contents): To list
					the contents of <code>/home/user/</code>, type: <pre>
						<code>ls</code>
					</pre> Output: <pre>
						<code>Documents  Music  Pictures</code>
					</pre></li>

				<li><strong><code>cd</code></strong> (Change Directory): To
					move into the <code>Documents</code> directory, type: <pre>
						<code>cd Documents</code>
					</pre></li>

				<li><strong><code>pwd</code> again:</strong> After changing
					into the <code>Documents</code> directory, typing <code>pwd</code>
					again will display: <pre>
						<code>/home/user/Documents</code>
					</pre></li>

				<li><strong>Absolute Path Example:</strong> To go to the <code>Music</code>
					directory from anywhere, you can use the absolute path: <pre>
						<code>cd /home/user/Music</code>
					</pre></li>

				<li><strong>Relative Path Example:</strong> If you're in the <code>Documents</code>
					directory and want to move up one level to <code>/home/user/</code>,
					use: <pre>
						<code>cd ..</code>
					</pre></li>
			</ul>

			<h3>4. Activity: Navigate to a Folder and Explore Its Contents</h3>
			<p>Let‚Äôs practice navigating the file system!</p>
			<ol>
				<li><strong>Navigate to a folder:</strong> - Open your terminal
					(WSL/Linux/macOS). - Use the <code>pwd</code> command to check your
					current directory. - Use <code>ls</code> to list the contents. -
					Move into a subdirectory using <code>
						cd
						<folder_name>
					</code>. - Try using both absolute and relative paths.</li>

				<li><strong>Explore directory contents:</strong> - Use <code>ls
						-l</code> to list files with details (permissions, file size, etc.). -
					Use <code>ls -a</code> to show hidden files. - Use <code>cd
						..</code> to go up one level in the directory.</li>

				<li><strong>Create a new file and directory:</strong> - Create
					a new directory with: <pre>
						<code>mkdir NewFolder</code>
					</pre> - Create a new file with: <pre>
						<code>touch newfile.txt</code>
					</pre> - List the contents with <code>ls</code> to confirm the changes.</li>
			</ol>
		</section>
		<section id="filemanagement">
			<h2>File Management in Linux (via WSL, Linux, or macOS)</h2>
			<p>Understanding file management is crucial for organizing your
				data and projects. Let‚Äôs cover some essential file management
				commands in Linux.</p>

			<h3>1. Key File Management Commands</h3>
			<ul>
				<li><strong><code>mkdir</code> (Make Directory):</strong> This
					command allows you to create a new directory (folder). <pre>
						<code>mkdir project_folder</code>
					</pre> Example output: (No output is returned on success, but the
					directory is created.)</li>

				<li><strong><code>touch</code> (Create Empty File):</strong>
					This command is used to create an empty file. It can also be used
					to update the timestamp of an existing file. <pre>
						<code>touch newfile.txt</code>
					</pre> Example output: (No output is returned on success, but the file is
					created.)</li>

				<li><strong><code>cp</code> (Copy Files/Directories):</strong>
					This command is used to copy files or directories. <pre>
						<code>cp file1.txt file2.txt</code>
					</pre> This copies `file1.txt` to `file2.txt`. <pre>
						<code>cp -r folder1 folder2</code>
					</pre> The `-r` option is used to copy directories recursively.</li>

				<li><strong><code>mv</code> (Move/Rename
						Files/Directories):</strong> This command moves or renames files and
					directories. <pre>
						<code>mv oldname.txt newname.txt</code>
					</pre> Example: This renames `oldname.txt` to `newname.txt`. <pre>
						<code>mv file1.txt /path/to/destination/</code>
					</pre> This moves `file1.txt` to a new directory.</li>

				<li><strong><code>rm</code> (Remove/Delete
						Files/Directories):</strong> This command is used to remove files or
					directories. <pre>
						<code>rm file1.txt</code>
					</pre> This deletes `file1.txt`. Be cautious as this is permanent. <pre>
						<code>rm -r folder1</code>
					</pre> The `-r` option allows you to remove directories and their
					contents recursively.</li>
			</ul>

			<h3>2. Creating and Organizing Directories</h3>
			<p>Creating a structured directory system is essential for
				organizing project files. Here's how you can organize your data:</p>

			<ul>
				<li><strong>Creating a new project directory:</strong> Use <code>mkdir</code>
					to create a new directory for your project: <pre>
						<code>mkdir my_project</code>
					</pre> This will create a directory called `my_project`.</li>

				<li><strong>Creating subdirectories:</strong> You can create
					multiple directories within your project folder to keep files
					organized: <pre>
						<code>mkdir my_project/input my_project/output my_project/scripts</code>
					</pre> This will create three subdirectories within `my_project` for
					organizing input data, output files, and scripts.</li>

				<li><strong>Creating files inside directories:</strong> Once
					you've set up your directories, you can create files in them using
					the <code>touch</code> command: <pre>
						<code>touch my_project/input/data.txt my_project/scripts/analysis.py</code>
					</pre> This will create two files: one in the `input` folder (`data.txt`)
					and another in the `scripts` folder (`analysis.py`).</li>
			</ul>

			<h3>3. Example Walkthrough: Organizing a Project</h3>
			<p>Let's walk through creating a project folder and organizing
				files:</p>
			<ul>
				<li><strong>Create the project folder:</strong> <pre>
						<code>mkdir my_bioinformatics_project</code>
					</pre> This creates the main folder for your project.</li>

				<li><strong>Create subdirectories:</strong> <pre>
						<code>mkdir my_bioinformatics_project/data my_bioinformatics_project/results my_bioinformatics_project/scripts</code>
					</pre> This organizes your project into folders for data, results, and
					scripts.</li>

				<li><strong>Create files:</strong> <pre>
						<code>touch my_bioinformatics_project/data/input_file.txt</code>
					</pre> <pre>
						<code>touch my_bioinformatics_project/scripts/preprocessing.sh</code>
					</pre> These files are created inside the appropriate directories.</li>

				<li><strong>Copy files into the project folder:</strong> <pre>
						<code>cp /path/to/external/input_file.txt my_bioinformatics_project/data/</code>
					</pre> This copies an existing file into the `data` directory.</li>

				<li><strong>Move files:</strong> If you want to reorganize, use
					<code>mv</code>: <pre>
						<code>mv my_bioinformatics_project/scripts/preprocessing.sh my_bioinformatics_project/scripts/analysis.sh</code>
					</pre> This renames the `preprocessing.sh` file to `analysis.sh`.</li>

				<li><strong>Delete unnecessary files:</strong> If a file is no
					longer needed, use <code>rm</code> to remove it: <pre>
						<code>rm my_bioinformatics_project/data/old_data.txt</code>
					</pre> This removes the old data file from your project.</li>
			</ul>

			<h3>4. Activity: Set Up a Project Folder with Dummy Files</h3>
			<p>Let‚Äôs practice by setting up a project folder and organizing
				it!</p>
			<ol>
				<li><strong>Create the project directory:</strong> - Open your
					terminal (WSL/Linux/macOS). - Run the following command: <pre>
						<code>mkdir bioinformatics_project</code>
					</pre></li>

				<li><strong>Create subdirectories for data, scripts,
						and results:</strong> - Create the following directories: <pre>
						<code>mkdir bioinformatics_project/data bioinformatics_project/scripts bioinformatics_project/results</code>
					</pre></li>

				<li><strong>Create some files:</strong> - Use the <code>touch</code>
					command to create dummy files: <pre>
						<code>touch bioinformatics_project/data/input_file.txt</code>
					</pre> <pre>
						<code>touch bioinformatics_project/scripts/analysis.sh</code>
					</pre></li>

				<li><strong>Copy a file into the project:</strong> - If you
					have an existing file (e.g., <code>sample_data.txt</code>), copy it
					into the project folder: <pre>
						<code>cp sample_data.txt bioinformatics_project/data/</code>
					</pre></li>

				<li><strong>Rename a file:</strong> - Rename the file
					`analysis.sh` to `preprocessing.sh`: <pre>
						<code>mv bioinformatics_project/scripts/analysis.sh bioinformatics_project/scripts/preprocessing.sh</code>
					</pre></li>

				<li><strong>Delete unnecessary files:</strong> - If there are
					files you no longer need, delete them with <code>rm</code>: <pre>
						<code>rm bioinformatics_project/data/old_file.txt</code>
					</pre></li>
			</ol>
		</section>
		<section id="links-linux">
			<h2>üîó Hard and Soft Links in Linux</h2>
			<p>
				Linux provides two types of links to reference files: <strong>hard
					links</strong> and <strong>soft links</strong> (also called symbolic links
				or symlinks). Understanding these is important for managing files
				efficiently.
			</p>

			<h3>üß± Hard Links</h3>
			<ul>
				<li>A hard link is an additional directory entry for a file.</li>
				<li>Hard links point directly to the file's data on disk
					(inode).</li>
				<li>Multiple hard links to the same file share the same inode
					and content.</li>
				<li>Deleting one hard link does not delete the file if other
					hard links exist.</li>
				<li>Hard links cannot span different filesystems or partitions.</li>
			</ul>
			<p>
				<strong>Example command to create a hard link:</strong>
			</p>
			<pre>
				<code>ln original_file.txt hard_link.txt</code>
			</pre>

			<h3>ü™¢ Soft (Symbolic) Links</h3>
			<ul>
				<li>A soft link is a special file that points to another file
					or directory by path.</li>
				<li>Soft links can point across filesystems and partitions.</li>
				<li>If the target file is deleted, the soft link becomes broken
					(dangling link).</li>
				<li>Soft links can link to directories as well as files.</li>
			</ul>
			<p>
				<strong>Example command to create a soft link:</strong>
			</p>
			<pre>
				<code>ln -s /path/to/original_file.txt soft_link.txt</code>
			</pre>

			<h3>üß™ Activity Suggestion</h3>
			<p>
				Try creating both a hard link and a soft link to a test file. Use
				<code>ls -li</code>
				to observe inode numbers and verify the differences.
			</p>
		</section>

		<section id="viewing">
			<h2>Viewing Files in Linux (via WSL, Linux, or macOS)</h2>
			<p>In bioinformatics, you often deal with large datasets, and
				knowing how to efficiently view files is crucial. In this section,
				we will explore several commands that can help you view the contents
				of files in the terminal.</p>

			<h3>1. Key Commands for Viewing Files</h3>
			<ul>
				<li><strong><code>cat</code> (Concatenate and View
						File Contents):</strong> The <code>cat</code> command is used to display
					the contents of a file directly in the terminal. It's best used for
					small files, as it prints the entire file at once. <pre>
						<code>cat filename.txt</code>
					</pre> Example output: <pre>
						<code>Welcome to bioinformatics training.</code>
					</pre>
					<p>
						<strong>Warning:</strong> Avoid using
						<code>cat</code>
						for large files, as it may overwhelm the terminal.
					</p></li>

				<li><strong><code>less</code> (View File
						Page-by-Page):</strong> The <code>less</code> command is useful for viewing
					large files, as it allows you to scroll through the file one page
					at a time. <pre>
						<code>less filename.txt</code>
					</pre> You can navigate using:
					<ul>
						<li><code>Space</code>: Scroll down one page</li>
						<li><code>Up/Down Arrow</code>: Move one line up/down</li>
						<li><code>q</code>: Quit and return to the terminal</li>
					</ul></li>

				<li><strong><code>head</code> (View the First Few
						Lines of a File):</strong> The <code>head</code> command shows the first 10
					lines of a file by default. It‚Äôs useful when you want to quickly
					check the beginning of a large file. <pre>
						<code>head filename.txt</code>
					</pre> To view a specific number of lines, use the <code>-n</code>
					option: <pre>
						<code>head -n 20 filename.txt</code>
					</pre> This shows the first 20 lines of the file.</li>

				<li><strong><code>tail</code> (View the Last Few Lines
						of a File):</strong> The <code>tail</code> command is the opposite of <code>head</code>;
					it shows the last 10 lines of a file by default. It‚Äôs useful for
					monitoring log files or large datasets where the latest information
					is more relevant. <pre>
						<code>tail filename.txt</code>
					</pre> To view the last few lines or monitor a file in real-time, use: <pre>
						<code>tail -n 20 filename.txt</code>
					</pre> This shows the last 20 lines of the file. <pre>
						<code>tail -f filename.txt</code>
					</pre> The <code>-f</code> option allows you to follow a file in
					real-time (useful for logs).</li>
			</ul>

			<h3>2. Best Tools for Viewing Large Data Files</h3>
			<p>When working with large data files, it's important to use the
				right tool to avoid overwhelming your terminal. Here‚Äôs a breakdown
				of the best tools:</p>
			<ul>
				<li><strong><code>less</code>:</strong> Ideal for viewing large
					files, as it loads the file one page at a time. You can scroll
					through the content and search within the file using <code>/search_term</code>
					and <code>n</code> to go to the next occurrence.</li>
				<li><strong><code>head</code> and <code>tail</code>:</strong>
					These are best when you only need to view the beginning or the end
					of the file, respectively. They are more efficient than loading the
					entire file into the terminal.</li>
				<li><strong><code>cat</code>:</strong> Only recommended for
					small files, as it prints the entire file to the terminal.</li>
			</ul>

			<h3>3. Example Walkthrough: Viewing Large Files</h3>
			<p>Let‚Äôs walk through the process of using these commands to view
				a large file, such as a `.txt` or `.tsv` file.</p>

			<ul>
				<li><strong>View a small file using <code>cat</code>:
				</strong> For a small file, simply use: <pre>
						<code>cat small_file.txt</code>
					</pre> This will display the entire contents of `small_file.txt` at once.
				</li>

				<li><strong>View a large file using <code>less</code>:
				</strong> If the file is large, use: <pre>
						<code>less large_file.txt</code>
					</pre> This will allow you to scroll through the content one page at a
					time, making it much easier to navigate large files.</li>

				<li><strong>View the first few lines of a file using <code>head</code>:
				</strong> If you only want to check the beginning of the file, use: <pre>
						<code>head large_file.txt</code>
					</pre> This will show the first 10 lines by default.</li>

				<li><strong>View the last few lines of a file using <code>tail</code>:
				</strong> To quickly check the end of a file (e.g., for logs or recent data),
					use: <pre>
						<code>tail large_file.txt</code>
					</pre> To monitor the file in real-time (for example, a log file that
					updates constantly), use: <pre>
						<code>tail -f large_file.txt</code>
					</pre></li>
			</ul>

			<h3>4. Activity: Open a `.txt` or `.tsv` File with Each Tool</h3>
			<p>Let's practice opening a file with each tool to better
				understand their usage and functionality.</p>
			<ol>
				<li><strong>Open a small `.txt` file with <code>cat</code>:
				</strong> - Open a terminal and run: <pre>
						<code>cat small_file.txt</code>
					</pre> - Verify that the entire file is printed to the terminal.</li>

				<li><strong>Open a large `.txt` file with <code>less</code>:
				</strong> - Use <code>less</code> to view a large file: <pre>
						<code>less large_file.txt</code>
					</pre> - Scroll through the file using the <code>Space</code> key and
					quit by pressing <code>q</code>.</li>

				<li><strong>Open the first 20 lines of a file with <code>head</code>:
				</strong> - Run the following to view the first 20 lines of a file: <pre>
						<code>head -n 20 large_file.txt</code>
					</pre></li>

				<li><strong>Open the last 20 lines of a file with <code>tail</code>:
				</strong> - View the last 20 lines of the file: <pre>
						<code>tail -n 20 large_file.txt</code>
					</pre></li>

				<li><strong>Monitor a log file with <code>tail
							-f</code>:
				</strong> - If you have a log file, use: <pre>
						<code>tail -f log_file.txt</code>
					</pre> - This will allow you to see updates to the log file in real-time.
				</li>
			</ol>

			<!-- 
    <h3>Expected Outcome:</h3>
    <ul>
        <li>Participants should be able to efficiently view small and large files using the appropriate commands.</li>
        <li>They will learn how to scroll through large files using <code>less</code>, view the first few lines with <code>head</code>, and view the last few lines with <code>tail</code>.</li>
        <li>By the end of the activity, they should feel comfortable using these commands to handle large datasets or logs in bioinformatics tasks.</li>
    </ul> -->
		</section>
		<section id="compressed">
			<h2>üóúÔ∏è Handling Compressed Files</h2>
			<p>Bioinformatics datasets often come as compressed archives. Use
				the following commands to unpack them:</p>

			<table border="1" cellpadding="8" cellspacing="0"
				style="border-collapse: collapse; width: 100%;">
				<thead>
					<tr>
						<th>Command</th>
						<th>Description</th>
						<th>Example</th>
					</tr>
				</thead>
				<tbody>
					<tr>
						<td><code>unzip</code></td>
						<td>Extract files from a <code>.zip</code> archive
						</td>
						<td><code>unzip samples.zip</code></td>
					</tr>
					<tr>
						<td><code>tar -xvf</code></td>
						<td>Extract contents from a <code>.tar</code> archive
						</td>
						<td><code>tar -xvf archive.tar</code></td>
					</tr>
					<tr>
						<td><code>tar -xzvf</code></td>
						<td>Extract a <code>.tar.gz</code> (gzip-compressed tar)
						</td>
						<td><code>tar -xzvf genome.tar.gz</code></td>
					</tr>
					<tr>
						<td><code>tar -xjvf</code></td>
						<td>Extract a <code>.tar.bz2</code> (bzip2-compressed tar)
						</td>
						<td><code>tar -xjvf data.tar.bz2</code></td>
					</tr>
					<tr>
						<td><code>gunzip</code></td>
						<td>Unzip a single <code>.gz</code> file
						</td>
						<td><code>gunzip reads.fastq.gz</code></td>
					</tr>
				</tbody>
			</table>
		</section>
		<section id="bioinformatics-file-formats">
			<h2>Bioinformatics File Formats</h2>
			<p>Bioinformatics relies on various file formats to store and
				exchange biological data. Below is an overview of some commonly used
				formats:</p>

			<dl>
				<dt>
					<strong>FASTQ</strong>
				</dt>
				<dd>
					A format for storing raw sequencing reads, typically compressed as
					<code>fastq.gz</code>
					. Each entry includes a sequence identifier, nucleotide sequence, a
					plus sign separator, and a quality score line. Essential for
					next-generation sequencing data analysis.
				</dd>

				<dt>
					<strong>FASTA</strong>
				</dt>
				<dd>A text-based format for representing nucleotide or peptide
					sequences. Each sequence begins with a header line starting with
					'>', followed by the sequence identifier and the sequence itself.
					Widely used for sequence alignment and database searches.</dd>

				<dt>
					<strong>Multi-FASTA</strong>
				</dt>
				<dd>Similar to FASTA but contains multiple sequences within a
					single file. Each sequence is separated by a header line, allowing
					for batch processing of sequences.</dd>

				<dt>
					<strong>GFF3 (General Feature Format Version 3)</strong>
				</dt>
				<dd>A format for describing genes and other features of DNA,
					RNA, and protein sequences. Each line represents a feature with
					fields for sequence name, source, type, start, end, and attributes.
					Important for annotating genomic features and gene structures.</dd>

				<dt>
					<strong>SAM (Sequence Alignment/Map)</strong>
				</dt>
				<dd>A text format for storing sequence alignment data. It
					includes a header section and an alignment section, with each
					alignment represented by a line containing various fields such as
					sequence name, position, mapping quality, and CIGAR string. SAM
					files are often compressed into BAM files for storage efficiency.</dd>

				<dt>
					<strong>VCF (Variant Call Format)</strong>
				</dt>
				<dd>A text file format for storing gene sequence variations,
					such as single nucleotide polymorphisms (SNPs) and
					insertions/deletions (InDels). Each line represents a variant,
					including information such as chromosome, position, and genotype.
					Crucial for genomic studies, particularly in identifying genetic
					variations.</dd>
			</dl>
		</section>
		<section id="pattern-matching">
			<h2>üîé Pattern Matching in Bash</h2>

			<h3>üåü Globbing (Wildcard Expansion)</h3>
			<p>Globbing lets you match file or folder names using special
				characters called wildcards:</p>
			<ul>
				<li><code>*</code>: Matches any number of characters (including
					none)</li>
				<li><code>?</code>: Matches exactly one character</li>
				<li><code>[abc]</code>: Matches one of the characters 'a', 'b',
					or 'c'</li>
				<li><code>[a-z]</code>: Matches any lowercase letter from a to
					z</li>
			</ul>
			<p>
				<strong>Example:</strong>
				<code>ls *.txt</code>
				‚Äî lists all files ending in
				<code>.txt</code>
				.
			</p>
			<p>
				<strong>Example:</strong>
				<code>ls data?.csv</code>
				‚Äî matches
				<code>data1.csv</code>
				,
				<code>dataA.csv</code>
				, but not
				<code>data12.csv</code>
				.
			</p>

			<h3>üìò Regular Expressions (Regex) ‚Äî Light Intro</h3>
			<p>
				Regular expressions are patterns used to match text. These can be
				used with text-viewing tools (like
				<code>cat</code>
				) and later with tools like
				<code>grep</code>
				.
			</p>
			<ul>
				<li><code>.</code>: Matches any single character</li>
				<li><code>*</code>: Repeats the previous pattern zero or more
					times</li>
				<li><code>^</code>: Anchors the match to the beginning of a
					line</li>
				<li><code>$</code>: Anchors the match to the end of a line</li>
			</ul>
			<p>
				<strong>Example:</strong>
				<code>cat myfile.txt</code>
				‚Äî view the file and look for lines that start with a specific
				pattern manually. (We‚Äôll later use tools to search automatically.)
			</p>

			<h3>üîÅ Summary Table</h3>
			<table border="1" cellspacing="0" cellpadding="5">
				<tr>
					<th>Feature</th>
					<th>Globbing</th>
					<th>Regex (Regular Expressions)</th>
				</tr>
				<tr>
					<td>Used For</td>
					<td>File and folder name matching</td>
					<td>Text pattern matching in file contents</td>
				</tr>
				<tr>
					<td>Example</td>
					<td><code>ls *.fasta</code></td>
					<td><code>^GATC</code> (matches lines starting with "GATC")</td>
				</tr>
				<tr>
					<td>Complexity</td>
					<td>Simple</td>
					<td>More flexible and powerful</td>
				</tr>
			</table>

			<p>
				We‚Äôll explore tools like
				<code>grep</code>
				and
				<code>awk</code>
				in the next section to put pattern matching into action!
			</p>
		</section>


		<section id="text-processing-tools">
			<h2>üîç Introduction to Text Processing Tools</h2>
			<p>In bioinformatics, many files are plain text ‚Äî like FASTA,
				GFF, or VCF files. Linux provides powerful tools to read, search,
				and manipulate these files directly from the terminal.</p>

			<h3>
				üìÑ
				<code>cat</code>
				‚Äì Concatenate and Display File Content
			</h3>
			<p>
				The
				<code>cat</code>
				command is used to display the contents of a file in the terminal.
			</p>
			<pre>
				<code>cat mydata.txt</code>
			</pre>
			<p>Useful for quickly viewing short files or combining multiple
				files.</p>

			<h3>
				üîé
				<code>grep</code>
				‚Äì Search for Patterns in Text
			</h3>
			<p>
				The
				<code>grep</code>
				command searches for lines that match a pattern.
			</p>
			<pre>
				<code>grep "gene" mydata.txt</code>
			</pre>
			<p>Use it to find specific terms (like gene names) in large
				files.</p>
			<ul>
				<li><code>-i</code>: Ignore case</li>
				<li><code>-v</code>: Invert match (exclude lines)</li>
				<li><code>-c</code>: Count matches</li>
			</ul>

			<h3>
				üî™
				<code>cut</code>
				‚Äì Extract Columns from Text
			</h3>
			<p>
				The
				<code>cut</code>
				command is used to extract specific fields (columns) from each line
				of a text file.
			</p>
			<pre>
				<code>cut -f1 mydata.tsv</code>
			</pre>
			<p>Extracts the first tab-delimited field. Useful for
				column-based data such as VCF or CSV/TSV files.</p>
			<ul>
				<li><code>-f</code>: Specify field/column number</li>
				<li><code>-d</code>: Set delimiter (default is tab)</li>
			</ul>

			<h3>
				üî§
				<code>tr</code>
				‚Äì Translate or Delete Characters
			</h3>
			<p>
				The
				<code>tr</code>
				command replaces or deletes characters in a stream.
			</p>
			<pre>
				<code>cat seq.txt | tr 'a-z' 'A-Z'</code>
			</pre>
			<p>Converts lowercase letters to uppercase. Works well with
				pipes.</p>
			<ul>
				<li><code>tr -d '\r'</code>: Delete carriage return characters</li>
				<li><code>tr ':' '\t'</code>: Replace colons with tabs</li>
			</ul>

			<h3>
				üõ†Ô∏è
				<code>awk</code>
				‚Äì Field-Based Text Processing
			</h3>
			<p>
				<code>awk</code>
				is a powerful tool for analyzing text files with column-based data
				(like TSV or CSV).
			</p>
			<pre>
				<code>awk '{print $1}' mydata.txt</code>
			</pre>
			<p>Prints the first column of each line.</p>
			<pre>
				<code>awk '$3 == "gene" {print $0}' annotations.gff</code>
			</pre>
			<p>Filters lines where the third column equals "gene".</p>

			<h3>
				‚úÇÔ∏è
				<code>sed</code>
				‚Äì Stream Editor for Modifying Text
			</h3>
			<p>
				<code>sed</code>
				is used to find and replace text in files or streams.
			</p>
			<pre>
				<code>sed 's/old/new/' file.txt</code>
			</pre>
			<p>Replaces the first instance of "old" with "new" in each line.</p>
			<ul>
				<li><code>s/old/new/g</code>: Replace all instances in each
					line</li>
				<li><code>sed -n 1,5p file.txt</code>: Print only lines 1 to 5</li>
			</ul>

			<h3>üß† Why These Tools Matter</h3>
			<p>These tools let you extract, transform, and analyze text data
				directly in the terminal ‚Äî without opening large files in a GUI or
				writing full scripts.</p>
			<p>You‚Äôll be using these tools together during Bash manipulation
				tasks and data preprocessing in pipelines.</p>
		</section>

		<section id="bash-bioinformatics">
			<h2>Bash Manipulation for Bioinformatics</h2>
			<p>Bash scripting is a powerful tool for processing and
				manipulating bioinformatics files. Below is a table summarizing
				common tasks and their corresponding commands.</p>

			<table border="1" cellpadding="8" cellspacing="0"
				style="border-collapse: collapse; width: 100%;">
				<thead style="background-color: #f2f2f2;">
					<tr>
						<th>Task</th>
						<th>Command</th>
						<th>Description</th>
					</tr>
				</thead>
				<tbody>
					<tr>
						<td>Extract FASTA header lines</td>
						<td><code>grep "^&gt;" mydata.fasta &gt; headers.txt</code></td>
						<td>Filters lines starting with '>' and saves them to <code>headers.txt</code>.
						</td>
					</tr>
					<tr>
						<td>Count FASTA header lines</td>
						<td><code>grep -c "^&gt;" mydata.fasta</code></td>
						<td>Counts the number of sequences (lines starting with '>')
							in the FASTA file.</td>
					</tr>
					<tr>
						<td>Save header lines to a file</td>
						<td><code>grep "^&gt;" mydata.fasta &gt; headers.txt</code></td>
						<td>Same as above ‚Äì saves all header lines to a file.</td>
					</tr>
					<tr>
						<td>Split multi-FASTA into files</td>
						<td><code>awk '/^&gt;/{if (seq) print seq &gt;
								filename; filename=$1; seq=""; next} {seq = seq $0} END{print
								seq &gt; filename}' mydata.fasta</code></td>
						<td>Splits a multi-sequence FASTA file into separate files
							based on sequence headers.</td>
					</tr>
					<tr>
						<td>Combine multiple FASTA files</td>
						<td><code>cat seq1.fasta seq2.fasta seq3.fasta &gt;
								combined.fasta</code></td>
						<td>Concatenates multiple FASTA files into one combined file.</td>
					</tr>
					<tr>
						<td>Extract gene info from GFF3</td>
						<td><code>awk '$3 == "gene" {print $9}' mydata.gff3 |
								cut -d ';' -f1 &gt; gene_info.txt</code></td>
						<td>Extracts gene attributes and saves gene IDs to <code>gene_info.txt</code>.
						</td>
					</tr>
					<tr>
						<td>Count genes in GFF3</td>
						<td><code>awk '$3 == "gene" {count++} END {print
								count}' mydata.gff3</code></td>
						<td>Counts the number of gene entries in a GFF3 file.</td>
					</tr>
					<tr>
						<td>Skip VCF metadata</td>
						<td><code>grep -v "^#" mydata.vcf &gt; data.vcf</code></td>
						<td>Removes metadata lines (starting with '#') from a VCF
							file.</td>
					</tr>
					<tr>
						<td>Filter VCF by quality</td>
						<td><code>awk '$6 &gt; 30' mydata.vcf &gt;
								filtered.vcf</code></td>
						<td>Filters variants with quality score greater than 30.</td>
					</tr>
				</tbody>
			</table>
		</section>

		<section id="io-redirection">
			<h2>I/O Redirection</h2>
			<p>In Linux, command-line programs typically receive input from
				the keyboard (standard input) and display output on the screen
				(standard output). I/O redirection allows you to change these
				default sources and destinations, enabling you to direct input and
				output to and from files or other commands.</p>
			<h3>Standard Streams</h3>
			<ul>
				<li><strong>Standard Input (stdin):</strong> The default source
					of input, usually the keyboard.</li>
				<li><strong>Standard Output (stdout):</strong> The default
					destination for output, usually the screen.</li>
				<li><strong>Standard Error (stderr):</strong> The default
					destination for error messages, usually the screen.</li>
			</ul>
			<h3>Output Redirection</h3>
			<p>Redirect the output of a command to a file:</p>
			<pre>
				<code>ls > file_list.txt</code>
			</pre>
			<p>
				This command writes the output of
				<code>ls</code>
				to
				<code>file_list.txt</code>
				, overwriting the file if it exists.
			</p>
			<p>Append the output to the end of a file without overwriting:</p>
			<pre>
				<code>ls >> file_list.txt</code>
			</pre>
			<p>
				This command adds the output of
				<code>ls</code>
				to the end of
				<code>file_list.txt</code>
				.
			</p>
			<h3>Input Redirection</h3>
			<p>Use a file as input to a command:</p>
			<pre>
				<code>wc -l < file_list.txt</code>
			</pre>
			<p>
				This command counts the number of lines in
				<code>file_list.txt</code>
				.
			</p>
			<h3>Pipes</h3>
			<p>Use the output of one command as the input to another:</p>
			<pre>
				<code>ls | head -3 > file.txt</code>
			</pre>
			<p>
				This command lists files, takes the first three lines, and writes
				them to
				<code>file.txt</code>
				.
			</p>
		</section>

		<section id="linux-process-control">
			<h2>Linux Process Control</h2>
			<p>A process is an instance of a running program, each identified
				by a unique Process Identifier (PID). Understanding process
				management is crucial for system administration and performance
				optimization.</p>

			<h3>Viewing Processes</h3>
			<p>
				<strong>ps</strong>: Displays a snapshot of current processes.
			</p>
			<pre>
				<code>ps aux</code>
			</pre>
			<p>This command lists all running processes with detailed
				information.</p>

			<p>
				<strong>top</strong>: Provides a real-time, dynamic view of system
				processes.
			</p>
			<pre>
				<code>top</code>
			</pre>
			<p>Press 'k' to kill a process, then enter the PID.</p>

			<h3>Managing Processes</h3>
			<p>
				<strong>kill</strong>: Terminates a process by sending a signal.
			</p>
			<pre>
				<code>kill -9 <PID>
				
				
				
				
				</code>
			</pre>
			<p>
				Use
				<code>-9</code>
				for a forceful termination.
			</p>

			<p>
				<strong>killall</strong>: Terminates processes by name.
			</p>
			<pre>
				<code>killall <process_name>
				
				
				
				
				</code>
			</pre>
			<p>This command is useful when you know the process name but not
				the PID.</p>

			<h3>Adjusting Process Priority</h3>
			<p>
				<strong>nice</strong>: Starts a process with a specified priority.
			</p>
			<pre>
				<code>nice -n 10 <command>
				
				
				
				
				</code>
			</pre>
			<p>Values range from -20 (highest priority) to 19 (lowest
				priority).</p>

			<p>
				<strong>renice</strong>: Changes the priority of an already running
				process.
			</p>
			<pre>
				<code>renice -n 10 -p <PID>
				
				
				
				
				</code>
			</pre>
			<p>Adjust the priority of a process identified by its PID.</p>
		</section>
		<section id="linux-job-control">
			<h2>Linux Job Control</h2>
			<p>
				In Linux, a <strong>job</strong> refers to a set of processes, such
				as a shell pipeline and any processes descended from it, all within
				the same process group. These jobs are identified by their job
				numbers and can be managed using various shell commands.
			</p>

			<h3>Job Control Commands</h3>
			<dl>
				<dt>
					<code>jobs</code>
				</dt>
				<dd>Displays the status of jobs in the current shell session.</dd>
				<dt>
					<code>fg [JOB_SPEC]</code>
				</dt>
				<dd>Brings a background job into the foreground, allowing
					interaction. If no job specification is provided, it resumes the
					most recent job.</dd>
				<dt>
					<code>bg [JOB_SPEC]</code>
				</dt>
				<dd>Resumes a suspended job in the background, allowing the
					terminal to be used for other tasks.</dd>
				<dt>
					<code>kill [PID]</code>
				</dt>
				<dd>Terminates a process by its Process ID (PID).</dd>
				<dt>
					<code>killall [PROCESS_NAME]</code>
				</dt>
				<dd>Terminates all processes with the specified name.</dd>
			</dl>

			<h3>Managing Jobs</h3>
			<p>To manage jobs effectively:</p>
			<ul>
				<li><strong>Suspend a job:</strong> Press <code>Ctrl+Z</code>
					to suspend a foreground job.</li>
				<li><strong>Bring a job to the foreground:</strong> Use <code>fg</code>
					to resume a suspended job in the foreground.</li>
				<li><strong>Send a job to the background:</strong> Use <code>bg</code>
					to resume a suspended job in the background.</li>
				<li><strong>Terminate a job:</strong> Use <code>kill</code>
					followed by the job's PID to terminate it.</li>
			</ul>

			<h3>Example</h3>
			<p>Consider the following example where a job is created and
				managed:</p>
			<pre>
				<code>cat file.txt | tr 'a-z' 'A-Z' > output.txt</code>
			</pre>
			<p>
				This command creates two processes:
				<code>cat</code>
				and
				<code>tr</code>
				. To manage these processes:
			</p>
			<ul>
				<li>Check the status of jobs: <code>jobs</code></li>
				<li>Bring a background job to the foreground: <code>fg
						%1</code></li>
				<li>Send a foreground job to the background: <code>bg %1</code></li>
				<li>Terminate a job: <code>kill %1</code></li>
			</ul>

			<p>
				For more detailed information on job control in Linux, refer to the
				<a href="https://www.redhat.com/en/blog/jobs-bg-fg">Red Hat
					article on jobs, bg, and fg</a>.
			</p>
		</section>
		<section id="linux-process-job-control">
			<h2>Linux Process & Job Control Commands</h2>
			<p>Efficiently managing processes and jobs is crucial for system
				administration. Below is a summary of essential commands for
				handling processes and jobs in Linux:</p>

			<dl>
				<dt>
					<code>ps</code>
				</dt>
				<dd>
					Lists currently running processes. Use
					<code>ps aux</code>
					for a detailed view.
				</dd>

				<dt>
					<code>top</code>
				</dt>
				<dd>Provides a real-time, dynamic view of system processes and
					resource usage.</dd>

				<dt>
					<code>kill</code>
				</dt>
				<dd>
					Terminates a process by its Process ID (PID). Use
					<code>kill -9 PID</code>
					for forceful termination.
				</dd>

				<dt>
					<code>nice</code>
				</dt>
				<dd>
					Starts a process with a specified priority. Use
					<code>nice -n 10 command</code>
					to set the priority.
				</dd>

				<dt>
					<code>jobs</code>
				</dt>
				<dd>Displays the status of jobs in the current session, showing
					job numbers and their states.</dd>

				<dt>
					<code>fg</code>
				</dt>
				<dd>
					Brings a background job into the foreground. Use
					<code>fg %1</code>
					to bring job 1 to the foreground.
				</dd>

				<dt>
					<code>bg</code>
				</dt>
				<dd>
					Resumes a suspended job in the background. Use
					<code>bg %1</code>
					to resume job 1 in the background.
				</dd>

				<dt>
					<code>Ctrl+C</code>
				</dt>
				<dd>Terminates the currently running foreground process by
					sending a SIGINT signal.</dd>

				<dt>
					<code>Ctrl+Z</code>
				</dt>
				<dd>Suspends the currently running foreground process by
					sending a SIGTSTP signal, allowing it to be resumed later.</dd>
			</dl>

			<p>
				For more detailed information and examples on managing jobs in
				Linux, refer to Jesin's Blog on job management in Linux: <a
					href="https://websistent.com/how-to-manage-jobs-in-linux-fg-bg-kill-ctrlz/">How
					to manage jobs in Linux - fg bg kill Ctrl+Z</a>
			</p>
		</section>

		<section id="shell-expansion">
			<h2>Shell Expansion</h2>
			<p>In the Bash shell, expansion refers to the process by which
				the shell interprets and transforms input before executing commands.
				Understanding these expansions is crucial for effective shell
				scripting and command-line usage.</p>
			<h3>Types of Shell Expansion</h3>
			<ol>
				<li><strong>Brace Expansion:</strong> Generates arbitrary
					strings. For example: <pre>
						<code>echo file{1..3}.txt</code>
					</pre> Output: <pre>
						<code>file1.txt file2.txt file3.txt</code>
					</pre></li>
				<li><strong>Tilde Expansion:</strong> Replaces the tilde (~)
					with the path to the home directory. For example: <pre>
						<code>cd ~</code>
					</pre> Changes to the current user's home directory.</li>
				<li><strong>Parameter and Variable Expansion:</strong> Replaces
					variables with their values. For example: <pre>
						<code>echo $HOME</code>
					</pre> Outputs the path of the home directory.</li>
				<li><strong>Command Substitution:</strong> Replaces a command
					with its output. For example: <pre>
						<code>echo "Today is $(date)"</code>
					</pre> Might output: <pre>
						<code>Today is Thu May 8 14:58:57 PHT 2025</code>
					</pre></li>
				<li><strong>Arithmetic Expansion:</strong> Evaluates arithmetic
					expressions. For example: <pre>
						<code>echo $((3 + 2))</code>
					</pre> Outputs: <pre>
						<code>5</code>
					</pre></li>
				<li><strong>Word Splitting:</strong> Splits the result of
					expansions into separate words based on the Internal Field
					Separator (IFS). For example: <pre>
						<code>list="one two three"
    for word in $list; do
      echo "$word"
    done</code>
					</pre> Outputs: <pre>
						<code>one
    two
    three</code>
					</pre></li>
				<li><strong>Filename Expansion (Globbing):</strong> Expands
					wildcard patterns to match filenames. For example: <pre>
						<code>ls *.txt</code>
					</pre> Lists all files ending with .txt in the current directory.</li>
			</ol>
			<h3>Order of Expansion</h3>
			<p>The shell performs expansions in the following order:</p>
			<ol>
				<li>Brace Expansion</li>
				<li>Tilde Expansion</li>
				<li>Parameter and Variable Expansion</li>
				<li>Command Substitution</li>
				<li>Arithmetic Expansion</li>
				<li>Word Splitting</li>
				<li>Filename Expansion</li>
			</ol>
			<p>Understanding this order is essential, as the output of one
				expansion can be the input for the next.</p>
		</section>

		<section id="shell-scripting">
			<h2>Shell Scripting</h2>
			<p>Shell scripting allows you to automate tasks by writing a
				series of commands in a text file, known as a script. To execute a
				shell script, you need to ensure it has the appropriate permissions
				and then run it using the terminal.</p>
			<h3>Creating a Shell Script</h3>
			<ol>
				<li>Create a new file with a <code>.sh</code> extension. For
					example: <pre>
						<code>nano myscript.sh</code>
					</pre>
				</li>
				<li>Add the shebang line at the top to specify the interpreter:
					<pre>
						<code>#!/bin/bash</code>
					</pre>
				</li>
				<li>Write your desired commands below the shebang line. For
					example: <pre>
						<code>#!/bin/bash
    echo "Hello, World!"</code>
					</pre>
				</li>
				<li>Save and exit the editor (in nano, press <code>Ctrl+O</code>
					to save and <code>Ctrl+X</code> to exit).
				</li>
			</ol>
			<h3>Changing File Permissions to Execute</h3>
			<p>
				Before running the script, you need to make it executable. Use the
				<code>chmod</code>
				command:
			</p>
			<pre>
				<code>chmod +x myscript.sh</code>
			</pre>
			<p>This command grants execute permission to the script, allowing
				it to be run as a program.</p>
			<h3>Running the Script</h3>
			<p>To execute the script, use one of the following methods:</p>
			<ul>
				<li>Run the script from the current directory: <pre>
						<code>./myscript.sh</code>
					</pre>
				</li>
				<li>Specify the full path to the script: <pre>
						<code>/path/to/myscript.sh</code>
					</pre>
				</li>
				<li>Use the <code>bash</code> command to run the script
					(execute permission not required in this case): <pre>
						<code>bash myscript.sh</code>
					</pre>
				</li>
			</ul>
			<p>
				Ensure that the script is located in a directory included in your
				system's
				<code>PATH</code>
				environment variable if you wish to run it without specifying the
				path.
			</p>
		</section>

		<section id="environment-variables">
			<h2>Environment Variables</h2>
			<p>Environment variables are key-value pairs that influence the
				behavior of processes and applications on a system. They store
				configuration settings, such as file locations or user preferences,
				and facilitate communication between different parts of the
				operating system.</p>
			<h3>Viewing Environment Variables</h3>
			<ul>
				<li>Display all environment variables: <pre>
						<code>printenv</code>
					</pre>
				</li>
				<li>Display a specific variable: <pre>
						<code>echo $VARIABLE_NAME</code>
					</pre>
				</li>
			</ul>
			<h3>Setting Environment Variables</h3>
			<ul>
				<li>Temporarily set a variable for the current session: <pre>
						<code>export VARIABLE_NAME="value"</code>
					</pre>
				</li>
				<li>To make a variable available to child processes: <pre>
						<code>export VARIABLE_NAME="value"</code>
					</pre>
				</li>
			</ul>
			<h3>Unsetting Environment Variables</h3>
			<ul>
				<li>Remove a variable from the current session: <pre>
						<code>unset VARIABLE_NAME</code>
					</pre>
				</li>
			</ul>
			<h3>Persistent Environment Variables</h3>
			<p>To retain environment variables across sessions, define them
				in configuration files:</p>
			<ul>
				<li>User-specific variables (affect only the current user):
					<ul>
						<li><code>~/.bashrc</code>: Loaded for interactive non-login
							shells.</li>
						<li><code>~/.bash_profile</code>: Loaded for login shells.</li>
					</ul> Add the export statement to one of these files: <pre>
						<code>export VARIABLE_NAME="value"</code>
					</pre> Then, apply the changes: <pre>
						<code>source ~/.bashrc</code>
					</pre>
				</li>
				<li>System-wide variables (affect all users):
					<ul>
						<li><code>/etc/environment</code>: Suitable for simple
							variable assignments.</li>
						<li><code>/etc/profile</code> or scripts in <code>/etc/profile.d/</code>:
							Used for more complex configurations.</li>
					</ul> Example of adding a variable to <code>/etc/environment</code>: <pre>
						<code>sudo nano /etc/environment
    # Add the line:
    VARIABLE_NAME="value"</code>
					</pre> After editing, apply the changes: <pre>
						<code>source /etc/environment</code>
					</pre>
				</li>
			</ul>
			<h3>Common Environment Variables</h3>
			<ul>
				<li><code>PATH</code>: Directories where the system looks for
					executable files.</li>
				<li><code>HOME</code>: The current user's home directory.</li>
				<li><code>LANG</code>: Defines the system's language and locale
					settings.</li>
				<li><code>USER</code>: The name of the current user.</li>
			</ul>
			<h3>Best Practices</h3>
			<ul>
				<li>Use clear and descriptive names for custom environment
					variables.</li>
				<li>Be cautious when modifying system-wide configuration files;
					incorrect settings can affect all users.</li>
				<li>Always back up configuration files before making changes.</li>
			</ul>
		</section>
		<section id="bashrc-bash_profile">
			<h2>
				Shell Configuration Files:
				<code>.bashrc</code>
				and
				<code>.bash_profile</code>
			</h2>
			<p>
				In the Bash shell, configuration files like
				<code>.bashrc</code>
				and
				<code>.bash_profile</code>
				are used to set up the environment and customize shell behavior.
				Understanding the differences between these files is essential for
				effective shell configuration.
			</p>
			<h3>
				<code>.bashrc</code>
			</h3>
			<ul>
				<li><strong>Purpose:</strong> Configures the shell for
					interactive non-login sessions.</li>
				<li><strong>Execution:</strong> Automatically executed when a
					new terminal window is opened or when a new Bash shell is started
					without logging in.</li>
				<li><strong>Common Uses:</strong>
					<ul>
						<li>Defining aliases (e.g., <code>alias ll='ls -la'</code>).
						</li>
						<li>Setting shell options and functions.</li>
						<li>Customizing the shell prompt (<code>PS1</code>).
						</li>
						<li>Configuring shell history behavior.</li>
					</ul></li>
			</ul>
			<h3>
				<code>.bash_profile</code>
			</h3>
			<ul>
				<li><strong>Purpose:</strong> Configures the shell for
					interactive login sessions.</li>
				<li><strong>Execution:</strong> Automatically executed when
					logging into the system via console, SSH, or when starting a login
					shell.</li>
				<li><strong>Common Uses:</strong>
					<ul>
						<li>Setting environment variables (e.g., <code>PATH</code>, <code>LANG</code>).
						</li>
						<li>Starting user-specific services or applications.</li>
						<li>Ensuring that <code>.bashrc</code> is sourced for login
							shells.
						</li>
					</ul></li>
			</ul>
			<h3>
				Best Practice: Source
				<code>.bashrc</code>
				from
				<code>.bash_profile</code>
			</h3>
			<p>
				To maintain consistency across login and non-login shells, it's
				common to source
				<code>.bashrc</code>
				from within
				<code>.bash_profile</code>
				:
			</p>
			<pre>
				<code>if [ -f ~/.bashrc ]; then
      . ~/.bashrc
    fi</code>
			</pre>
			<p>
				This ensures that the configurations in
				<code>.bashrc</code>
				are applied in all interactive sessions.
			</p>
			<h3>
				Exercise: Inspect Your
				<code>.bashrc</code>
				File
			</h3>
			<p>
				To view your current
				<code>.bashrc</code>
				configurations, use the following command:
			</p>
			<pre>
				<code>less ~/.bashrc</code>
			</pre>
			<p>
				This will display the contents of your
				<code>.bashrc</code>
				file, allowing you to review and understand the customizations
				applied to your shell environment.
			</p>
		</section>
		<section id="linux-tips">
			<h2>Essential Linux Tips</h2>
			<h3>
				Understanding the
				<code>$PATH</code>
				Variable
			</h3>
			<p>
				The
				<code>$PATH</code>
				variable is a colon-delimited list of directories that the shell
				searches through when you enter a command. The directories are
				checked in the order they're listed, so if multiple directories
				contain executables with the same name, the first one found is
				executed :contentReference[oaicite:0]{index=0}.
			</p>
			<h3>Viewing Hidden Files</h3>
			<p>
				To view hidden files (those starting with a dot, e.g.,
				<code>.bashrc</code>
				), use the
				<code>-a</code>
				option with the
				<code>ls</code>
				command:
			</p>
			<pre>
				<code>ls -a</code>
			</pre>
			<p>This will display all files, including hidden ones, in the
				current directory.</p>
			<h3>Handling Filenames with Spaces</h3>
			<p>Filenames with spaces can be tricky in the terminal. To handle
				them:</p>
			<ul>
				<li>Enclose the filename in quotes: <pre>
						<code>cd "My Folder"</code>
					</pre>
				</li>
				<li>Escape each space with a backslash: <pre>
						<code>cd My\ Folder</code>
					</pre>
				</li>
			</ul>
			<p>Alternatively, you can use tab completion to automatically
				escape spaces.</p>
			<h3>Clearing the Terminal Screen</h3>
			<p>
				To clear the terminal screen, you can use the
				<code>clear</code>
				command:
			</p>
			<pre>
				<code>clear</code>
			</pre>
			<p>For a more thorough reset, use:</p>
			<pre>
				<code>reset</code>
			</pre>
			<p>This command reinitializes the terminal, clearing the screen
				and resetting settings :contentReference[oaicite:1]{index=1}.</p>
			<h3>
				Using
				<code>sudo</code>
				for Elevated Privileges
			</h3>
			<p>
				The
				<code>sudo</code>
				command allows you to run commands with elevated privileges,
				typically as the root user. This is useful for administrative tasks
				like installing software or modifying system configurations
				:contentReference[oaicite:2]{index=2}.
			</p>
			<p>
				To use
				<code>sudo</code>
				, prefix your command with it:
			</p>
			<pre>
				<code>sudo command</code>
			</pre>
			<p>You'll be prompted to enter your password to confirm your
				identity.</p>
		</section>

		<section id="quiz">
			<h2>üìò Linux Terminal Practice: Folder Navigation & File
				Inspection</h2>
			<p>Use the terminal to complete each task. If the command works,
				write down the result. If it returns an error, copy the exact error
				message from your terminal. In some tasks, you‚Äôll be asked what
				command you would use to achieve a certain outcome.</p>
			<p>
				<strong>üìù Instructions:</strong>
			</p>

			<ul>
				<li>1. Write all your answers in a plain text file named <code>yourLastname_activity1.txt</code>.
					Once done, submit the file to: <strong>.....</strong>.
				</li>
				<li>2. Download this file: <a
					href="/bbc2025v1/docs/2025/module1_basic_linux/resources/bio_training.zip"><strong>bio_training.zip</strong></a>.
				</li>
			</ul>


			<h3>üì¶ Task 0: Extract the training archive</h3>
			<pre>
				<code>unzip bio_training.zip</code>
			</pre>
			<p>
				<strong>Q1:</strong> Did the folder
				<code>bio_training/</code>
				get created successfully?
			</p>
			<p>
				<strong>Q2:</strong> If there was an error, what was the exact
				message? What command should be use?
			</p>

			<h3>üîç Task 1: Navigate to a folder</h3>
			<pre>
				<code>cd /bio_training/projectA/data</code>
			</pre>
			<p>
				<strong>Q1:</strong> What are the names of the files in this
				directory? Use
				<code>ls</code>
				to list them.
			</p>
			<p>
				<strong>Q2:</strong> Did the command work? If not, What should
				command be use to go to data folder under projectA?
			</p>

			<h3>üìÑ Task 2: View a file</h3>
			<pre>
				<code>cat exp1.tsv</code>
			</pre>
			<p>
				<strong>Q1:</strong> What is the content of the file? Can you spot
				the gene with the highest expression?
			</p>
			<p>
				<strong>Q2:</strong> Did the command work? If not, what exact error
				message did you see?
			</p>

			<h3>üìÇ Task 3: Count number of files in a directory</h3>
			<pre>
				<code>ls | wc -l</code>
			</pre>
			<p>
				<strong>Q1:</strong> How many items (files and folders) are listed?
			</p>
			<p>
				<strong>Q2:</strong> What command would you use to list the actual
				names instead of just the count?
			</p>

			<h3>üìú Task 4: Check logs</h3>
			<pre>
				<code>tail -n 1 ../results/error.log</code>
			</pre>
			<p>
				<strong>Q1:</strong> What does the last line of the error log say?
			</p>
			<p>
				<strong>Q2:</strong> Did the command work? If not, what exact error
				message did you see?
			</p>

			<h3>üîç Task 5: Search metadata</h3>
			<pre>
				<code>grep FAIL ../../projectB/metadata/samples.tsv</code>
			</pre>
			<p>
				<strong>Q1:</strong> Which samples failed the quality check?
			</p>
			<p>
				<strong>Q2:</strong> What command should be used if we want to
				ignore uppercase/lowercase differences?
			</p>

			<h3>üî¢ Task 6: Count lines in a log file</h3>
			<pre>
				<code>wc -l ../../projectB/logs/pipeline.log</code>
			</pre>
			<p>
				<strong>Q1:</strong> How many lines are in the log file?
			</p>
			<p>
				<strong>Q2:</strong> What command would you use to count the number
				of words instead?
			</p>

			<h3>üìÅ Task 7: Create a new folder and file</h3>
			<pre>
				<code>mkdir analysis && touch analysis/summary.txt</code>
			</pre>
			<p>
				<strong>Q1:</strong> What command would show the full absolute path
				of the new file?
			</p>
			<p>
				<strong>Q2:</strong> What command would you use to confirm that the
				file is empty?
			</p>
		</section>
		</br> </br> </br>
	</main>


</body>
</html>
