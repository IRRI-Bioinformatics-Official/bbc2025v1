<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Basic Linux Course</title>
  <style>
    body {
      font-family: Arial, sans-serif;
      margin: 0;
      padding: 0;
      line-height: 1.6;
      display: flex;

    }
    html, body {
      height: 100%;
      overflow: auto;
      overscroll-behavior: contain;
    }

    /* Floating Table of Contents */
    #toc {
      position: fixed;
      top: 0px;
      left: 20px;
      width: 200px;
      background-color: #f8f9fa;
      padding: 1rem;
      border-radius: 8px;
      box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
      z-index: 1000;
    }
    #toc h2 {
      font-size: 1.2rem;
      margin-bottom: 1rem;
    }
    #toc ul {
      list-style-type: none;
      padding: 0;
    }
    #toc ul li {
      margin: 0.5rem 0;
    }
    #toc ul li a {
      text-decoration: none;
      color: #007bff;
    }
    #toc ul li a:hover {
      text-decoration: underline;
    }
    /* Main content styling */
    main {
      margin-left: 240px; /* Adjusted for TOC width */
      padding: 2rem;
      flex-grow: 1;
    }
    h1, h2 {
      color: #2c3e50;
    }
    section {
      margin-bottom: 2rem;
      
    }
  </style>
</head>
<body>
  <script>
    document.addEventListener("DOMContentLoaded", function () {
      const tocLinks = document.querySelectorAll('#toc a[data-target]');
      tocLinks.forEach(link => {
        link.addEventListener('click', function (e) {
          e.preventDefault();
          const targetId = this.getAttribute('data-target');
          const targetElement = document.getElementById(targetId);
          if (targetElement) {
            targetElement.scrollIntoView({ behavior: 'smooth', block: 'start' });
          }
        });
      });
    });
  </script>
  <!-- Floating Table of Contents -->
  <div id="toc">
    <h2>Table of Contents</h2>
    <ul>
      <li><a href="#" data-target="gui-overview">Linux GUI</a></li>
      <li><a href="#" data-target="wsl">Windows Subsystem for Linux (WSL)</a></li>
      <li><a href="#" data-target="cli-overview">The Command Line Interface (CLI)</a></li>
      <li><a href="#" data-target="linux-filesystem">Linux File System Tree</a></li>
      <li><a href="#" data-target="file-permissions">File Permissions</a></li>
      <li><a href="#" data-target="hard-soft-links">Hard and Soft Links</a></li>
      <li><a href="#" data-target="io-redirection">I/O Redirection</a></li>
    </ul>
  </div>

  
  <!-- Main Content -->
  <main>
   
    <section id="gui-overview">
      <h2>The Graphical User Interface (GUI)</h2>
      <p>
        A Graphical User Interface (GUI) is a visual way for users to interact with electronic devices, utilizing graphical elements such as icons, buttons, and windows. Unlike text-based command-line interfaces, GUIs allow users to navigate and operate systems through intuitive visual indicators.
      </p>
      <p>
        In Linux, as in Windows and macOS, GUIs provide a user-friendly environment where actions are performed primarily using input devices like a mouse for computers or touch gestures for smartphones and tablets. This visual approach simplifies complex operations, making computing more accessible to a broader range of users.
      </p>
    </section>
    
    <section id="wsl">
      <h2>Windows Subsystem for Linux (WSL) 
      </h2>
      <p>WSL is a compatibility layer that enables users to operate a complete GNU/Linux environment seamlessly on a Windows system, eliminating the need for dual-boot setups. With WSL, users can execute Linux command-line utilities and applications directly within Windows.
      </p>
    </section>

    <section id="cli-overview">
      <h2>The Command Line Interface (CLI)</h2>
      <p>
        The Command Line Interface (CLI) is a text-based interface that allows users to interact with the computer by typing commands using the keyboard. Unlike Graphical User Interfaces (GUIs), the CLI does not rely on point-and-click interactions, making it essential to learn basic commands to navigate the file system and perform tasks.
      </p>
      <p>
        In the field of bioinformatics, proficiency in the CLI is crucial. Many bioinformatics tools are designed to run exclusively through the command line, offering advanced functionalities not available in their GUI counterparts. For instance, tools like BLAST provide additional capabilities when accessed via the CLI :contentReference[oaicite:4]{index=4}.
      </p>
      <p>
        Moreover, bioinformatics analyses often require processing large datasets that demand substantial memory and computational power. Such tasks are typically performed on High-Performance Computing (HPC) systems or cloud servers, which are accessed remotely through the CLI. Therefore, mastering the command line is not just beneficial but essential for bioinformatics students and professionals.
      </p>
    </section>

    <section id="linux-filesystem">
      <h2>Linux File System Tree</h2>
      <p>
        The Linux file system is organized in a hierarchical tree structure, starting from the root directory denoted by <code>/</code>. This structure follows the Filesystem Hierarchy Standard (FHS), ensuring consistency across different Linux distributions.
      </p>
    
      <h3>The Path</h3>
      <ul>
        <li><strong>Absolute Path:</strong> Specifies the complete path from the root directory to the desired file or directory. For example, <code>/home/user/documents</code>.</li>
        <li><strong>Relative Path:</strong> Specifies the path relative to the current working directory. For example, <code>documents/report.txt</code> refers to a file within the <code>documents</code> directory inside the current directory.</li>
      </ul>
    
      <h3>Navigating the File System</h3>
      <ul>
        <li><code>cd</code> – Change the current directory.</li>
        <li><code>ls</code> – List the contents of a directory.</li>
        <li><code>pwd</code> – Display the current working directory.</li>
        <li><code>mkdir</code> – Create a new directory.</li>
        <li><code>cp</code> – Copy files or directories.</li>
        <li><code>mv</code> – Move or rename files or directories.</li>
        <li><code>rm</code> – Remove files or directories.</li>
        <li><code>less</code> – View the contents of a file one page at a time.</li>
        <li><code>head -n</code> – View the first <code>n</code> lines of a file.</li>
        <li><code>tail -n</code> – View the last <code>n</code> lines of a file.</li>
      </ul>
    
      <h3>Special Symbols</h3>
      <ul>
        <li><code>.</code> – Represents the current directory.</li>
        <li><code>..</code> – Represents the parent directory.</li>
        <li><code>~</code> – Represents the home directory of the current user.</li>
      </ul>
    </section>
    <section id="file-permissions">
      <h2>File Permissions</h2>
      <p>
        File permissions dictate who can read, write, or execute a file on a computer system. In Unix-like operating systems, including Linux, files have three sets of permissions:
      </p>
      <ul>
        <li><strong>Read (r):</strong> Allows viewing the contents of a file.</li>
        <li><strong>Write (w):</strong> Allows modifying or deleting the file.</li>
        <li><strong>Execute (x):</strong> Allows running the file as a program or script.</li>
      </ul>
      <p>
        These permissions are assigned to three categories of users:
      </p>
      <ul>
        <li><strong>Owner (u):</strong> The user who created the file.</li>
        <li><strong>Group (g):</strong> A set of users who share certain permissions.</li>
        <li><strong>Others (o):</strong> All other users not in the owner or group categories.</li>
      </ul>
      <p>
        Permissions are represented symbolically (e.g., <code>rwxr-xr--</code>) or numerically (e.g., <code>754</code>). For example, <code>rwxr-xr--</code> means:
      </p>
      <ul>
        <li><strong>Owner:</strong> Read, write, and execute permissions.</li>
        <li><strong>Group:</strong> Read and execute permissions.</li>
        <li><strong>Others:</strong> Read permission only.</li>
      </ul>
      <p>
        To view file permissions, use the command:
      </p>
      <pre><code>ls -lht</code></pre>
      <p>
        The first character indicates the file type:
      </p>
      <ul>
        <li><code>-</code>: Regular file</li>
        <li><code>d</code>: Directory</li>
        <li><code>l</code>: Symbolic link</li>
      </ul>
      <p>
        The next nine characters represent permissions for the owner, group, and others, respectively.
      </p>
      <h3>Changing Permissions with <code>chmod</code></h3>
      <p>
        The <code>chmod</code> command modifies file permissions. It supports both symbolic and numeric modes.
      </p>
      <h4>Symbolic Mode</h4>
      <p>
        Syntax:
      </p>
      <pre><code>chmod [who][operator][permissions] filename</code></pre>
      <p>
        Where:
      </p>
      <ul>
        <li><strong>who:</strong> <code>u</code> (owner), <code>g</code> (group), <code>o</code> (others), <code>a</code> (all)</li>
        <li><strong>operator:</strong> <code>+</code> (add), <code>-</code> (remove), <code>=</code> (set exactly)</li>
        <li><strong>permissions:</strong> <code>r</code> (read), <code>w</code> (write), <code>x</code> (execute)</li>
      </ul>
      <p>
        Example:
      </p>
      <pre><code>chmod u+rw file1</code></pre>
      <p>
        This command adds read and write permissions to the owner of <code>file1</code>.
      </p>
      <h4>Numeric (Octal) Mode</h4>
      <p>
        Each permission is represented by a number:
      </p>
      <ul>
        <li><code>4</code>: Read</li>
        <li><code>2</code>: Write</li>
        <li><code>1</code>: Execute</li>
      </ul>
      <p>
        The sum of these numbers represents the permissions for each user category. For example:
      </p>
      <ul>
        <li><strong>Owner:</strong> Read (4) + Write (2) = <code>6</code></li>
        <li><strong>Group:</strong> Read (4) + Write (2) = <code>6</code></li>
        <li><strong>Others:</strong> Read (4) + Write (2) + Execute (1) = <code>7</code></li>
      </ul>
      <p>
        Combined, the numeric mode is <code>667</code>. To apply these permissions:
      </p>
      <pre><code>chmod 667 file1</code></pre>
      <p>
        This sets the specified permissions for <code>file1</code>.
      </p>
    </section>
    <section id="hard-soft-links">
      <h2>Hard and Soft Links</h2>
      <p>
        In Linux, links are pointers that reference files. There are two primary types of links:
      </p>
      <h3>Hard Links</h3>
      <p>
        A hard link is an additional name for an existing file. It points directly to the inode (the data structure that stores file information) of the file. This means:
      </p>
      <ul>
        <li>All hard links to a file share the same inode number.</li>
        <li>Modifying the content through any hard link affects all others.</li>
        <li>Deleting the original file does not remove the data as long as at least one hard link exists.</li>
        <li>Hard links cannot span across different file systems or be created for directories (to prevent recursive loops).</li>
      </ul>
      <p>
        To create a hard link:
      </p>
      <pre><code>ln file1.txt hardlink.txt</code></pre>
      <h3>Soft (Symbolic) Links</h3>
      <p>
        A soft link, or symbolic link, is a special file that points to another file or directory by name. Characteristics include:
      </p>
      <ul>
        <li>It has its own inode and contains the pathname of the target file.</li>
        <li>Soft links can span across different file systems.</li>
        <li>If the target file is deleted or moved, the soft link becomes a dangling link and does not work.</li>
        <li>They can link to directories.</li>
      </ul>
      <p>
        To create a soft link:
      </p>
      <pre><code>ln -s file1.txt softlink.txt</code></pre>
      <h3>Key Differences</h3>
      <table>
        <thead>
          <tr>
            <th>Feature</th>
            <th>Hard Link</th>
            <th>Soft Link</th>
          </tr>
        </thead>
        <tbody>
          <tr>
            <td>Inode</td>
            <td>Same as target</td>
            <td>Different from target</td>
          </tr>
          <tr>
            <td>Cross-file system</td>
            <td>No</td>
            <td>Yes</td>
          </tr>
          <tr>
            <td>Link to directories</td>
            <td>No</td>
            <td>Yes</td>
          </tr>
          <tr>
            <td>Effect of deleting target</td>
            <td>Data remains accessible</td>
            <td>Link becomes invalid</td>
          </tr>
        </tbody>
      </table>
    </section>
    <section id="io-redirection">
      <h2>I/O Redirection</h2>
      <p>
        In Linux, command-line programs typically receive input from the keyboard (standard input) and display output on the screen (standard output). I/O redirection allows you to change these default sources and destinations, enabling you to direct input and output to and from files or other commands.
      </p>
      <h3>Standard Streams</h3>
      <ul>
        <li><strong>Standard Input (stdin):</strong> The default source of input, usually the keyboard.</li>
        <li><strong>Standard Output (stdout):</strong> The default destination for output, usually the screen.</li>
        <li><strong>Standard Error (stderr):</strong> The default destination for error messages, usually the screen.</li>
      </ul>
      <h3>Output Redirection</h3>
      <p>
        Redirect the output of a command to a file:
      </p>
      <pre><code>ls > file_list.txt</code></pre>
      <p>
        This command writes the output of <code>ls</code> to <code>file_list.txt</code>, overwriting the file if it exists.
      </p>
      <p>
        Append the output to the end of a file without overwriting:
      </p>
      <pre><code>ls >> file_list.txt</code></pre>
      <p>
        This command adds the output of <code>ls</code> to the end of <code>file_list.txt</code>.
      </p>
      <h3>Input Redirection</h3>
      <p>
        Use a file as input to a command:
      </p>
      <pre><code>wc -l < file_list.txt</code></pre>
      <p>
        This command counts the number of lines in <code>file_list.txt</code>.
      </p>
      <h3>Pipes</h3>
      <p>
        Use the output of one command as the input to another:
      </p>
      <pre><code>ls | head -3 > file.txt</code></pre>
      <p>
        This command lists files, takes the first three lines, and writes them to <code>file.txt</code>.
      </p>
    </section>
    
        
    
    
    
  </main>

</body>
</html>
