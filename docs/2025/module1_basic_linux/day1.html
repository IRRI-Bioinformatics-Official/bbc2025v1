<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Basic Linux Course</title>
  <style>
    body {
      font-family: Arial, sans-serif;
      margin: 0;
      padding: 0;
      line-height: 1.6;
      display: flex;

    }
    html, body {
      height: 100%;
      overflow: auto;
      overscroll-behavior: contain;
    }

    /* Floating Table of Contents */
    #toc {
      position: fixed;
      top: 0px;
      left: 20px;
      width: 200px;
      background-color: #f8f9fa;
      padding: 1rem;
      border-radius: 8px;
      box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
      z-index: 1000;
    }
    #toc h2 {
      font-size: 1.2rem;
      margin-bottom: 1rem;
    }
    #toc ul {
      list-style-type: none;
      font-size: .9rem;
      padding: 0;
    }
    
    #toc ul li {
      margin: 0.5rem 0;
    }
    #toc ul li a {
      text-decoration: none;
      color: #007bff;
    }
    #toc ul li a:hover {
      text-decoration: underline;
    }
    /* Main content styling */
    main {
      margin-left: 240px; /* Adjusted for TOC width */
      padding: 2rem;
      flex-grow: 1;
    }
    h1, h2 {
      color: #2c3e50;
    }
    
     section {
     		margin-bottom: 2rem;
            max-width: 800px;
            padding: 20px;
            background-color: white;
            border-radius: 8px;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.1);
        }
        pre, code {
            background-color: #ededed;
            color: #312f2f;
            padding: 5px 10px;
            border-radius: 4px;
            font-size: .9em;
            font-family: Consolas, monospace;
        }
        code {
            font-size: 1em;
            background-color: #ededed;
            padding: 2px 5px;
            border-radius: 3px;
        }
        ul {
            list-style-type: none;
            padding-left: 20px;
        }
        ul li {
            margin-bottom: 10px;
        }
        ol {
            padding-left: 20px;
        }
        li {
            margin-bottom: 10px;
        }
        strong {
            color: #2c3e50;
        }
  </style>
</head>
<body>
  <script>
    document.addEventListener("DOMContentLoaded", function () {
      const tocLinks = document.querySelectorAll('#toc a[data-target]');
      tocLinks.forEach(link => {
        link.addEventListener('click', function (e) {
          e.preventDefault();
          const targetId = this.getAttribute('data-target');
          const targetElement = document.getElementById(targetId);
          if (targetElement) {
            targetElement.scrollIntoView({ behavior: 'smooth', block: 'start' });
          }
        });
      });
    });
  </script>
  <!-- Floating Table of Contents -->
  <div id="toc">
    <h2>Day 1: </h2>
    <ul>
       <li><a href="#" data-target="overview">i. Overview</a></li>
      <li><a href="#" data-target="os">I. Operating Systems</a></li>
      <li><a href="#" data-target="why-linux">II. Why Linux is Important in Bioinformatics</a></li>
      <li><a href="#" data-target="linux-better">III. Why Linux is Better Than GUI (Graphical User Interface) Tools</a></li>
      <li><a href="#" data-target="filesystem">IV. Filesystem Navigation </a></li>
      <li><a href="#" data-target="filemanagement">V. File Management</a></li>
      <li><a href="#" data-target="viewing">VI. Viewing Files in Linux</a></li>
      <li><a href="#" data-target="compressed">VII. Handling Compressed File</a></li>
      <li><a href="#" data-target="quiz">VIII. Activity</a></li>
      <li><a href="/bbc2025v1/docs/2025/module1_basic_linux/day1_cheatsheet.html" target="blank">IX. Cheat Sheet</a></li>
    </ul>
  </div>

  
  <!-- Main Content -->
  <main>
   <section id="overview">
  <h2>üß≠ Training Overview: Linux Basics, Filesystem, and Shell Navigation</h2>

  <h3>üéØ Topic</h3>
  <p>Linux Basics, Filesystem, and Shell Navigation</p>

  <h3>üë• Target Audience</h3>
  <p>Beginners in bioinformatics ‚Äî no prior Linux experience required.</p>

  <h3>üèÅ Goal</h3>
  <p>Help participants become comfortable using the Linux terminal and executing essential file and folder commands commonly used in bioinformatics workflows.</p>
</section>
   
   <section id="os">
    <h2>Understanding Operating Systems for Bioinformatics</h2>
    <p>When working with bioinformatics tools, it's essential to understand the differences between operating systems (OS) like <strong>Windows</strong>, <strong>Linux</strong>, and <strong>macOS</strong>, as well as how to bridge the gap between them using tools like <strong>WSL (Windows Subsystem for Linux)</strong>.</p>

    <h3>1. Windows vs. Linux vs. macOS</h3>
    <ul>
        <li><strong>Windows</strong> is a popular OS for general use and is often used in corporate environments. While it has GUI-based tools, it can be limiting when working with command-line-heavy bioinformatics workflows. Many bioinformatics tools are not natively supported on Windows, requiring workarounds like WSL or virtual machines.</li>
        <li><strong>Linux</strong> is the preferred OS for bioinformatics because it offers superior performance, stability, and extensive command-line tools designed specifically for computational tasks and data analysis. Most bioinformatics software is optimized for Linux.</li>
        <li><strong>macOS</strong> is similar to Linux in terms of underlying architecture (both are Unix-based), so many bioinformatics tools that run on Linux can also run on macOS. It's often preferred by researchers who need a balance of ease of use (macOS GUI) and command-line functionality. It offers strong support for development environments and bioinformatics software, though some specialized Linux tools might require additional setup.</li>
    </ul>

    <h3>2. Windows Subsystem for Linux (WSL)</h3>
    <ul>
        <li><strong>WSL</strong> allows Windows users to run a Linux environment directly on top of Windows without the need for dual-booting or using virtual machines.</li>
        <li>WSL provides a full Linux kernel, enabling users to install and run popular bioinformatics tools that are typically only available on Linux.</li>
        <li><strong>Advantages of WSL:</strong></li>
        <ul>
            <li>Easy access to both Windows and Linux tools in one environment.</li>
            <li>Ideal for Windows users who need to run Linux tools without switching OS.</li>
            <li>Access to the Linux file system and native Linux utilities directly from Windows.</li>
        </ul>
        <li><strong>Limitations of WSL:</strong></li>
        <ul>
            <li>Some high-performance tools might not run as efficiently as on a full Linux system.</li>
            <li>While WSL 2 supports a full Linux kernel, it still operates within Windows, which could affect performance with very large datasets or computationally intensive tasks.</li>
        </ul>
    </ul>

    <h3>3. Choosing the Right OS for Your Work</h3>
    <ul>
        <li><strong>Linux</strong> is the best option for bioinformatics work, as it provides the best performance, efficiency, and native support for bioinformatics tools.</li>
        <li><strong>macOS</strong> is a good alternative if you need the Unix environment but prefer a more user-friendly GUI. It‚Äôs compatible with most bioinformatics tools and is widely used by researchers who prefer working with a Mac.</li>
        <li><strong>Windows</strong> is less ideal for bioinformatics but can be used effectively with tools like WSL to run Linux-based tools without switching OSs.</li>
        <li>If you‚Äôre a Windows user and need Linux tools, <strong>WSL</strong> is a great option to get the Linux environment without leaving Windows.</li>
        <li>For macOS users, using a native Unix-based environment makes it easy to run bioinformatics tools, but certain specialized Linux tools might require additional setup or a virtual machine.</li>
    </ul>
</section>
   
    <section id="why-linux">
    <h2>Why Linux is Important in Bioinformatics</h2>
    <ul>
        <li><strong>Most Bioinformatics Tools Are Built for Linux:</strong> Many tools used in bioinformatics, like those for gene analysis and sequencing, work best on Linux systems.</li>
        <li><strong>Free and Open Source:</strong> Linux is free to use, and bioinformatics software is often open-source, meaning anyone can use, modify, and share it.</li>
        <li><strong>Handles Large Data Efficiently:</strong> Bioinformatics involves working with huge data files (like genome data). Linux is good at managing and processing large amounts of data quickly.</li>
        <li><strong>Works Well with High-Performance Computers:</strong> Many research labs use powerful Linux-based computers (called clusters) to analyze data faster.</li>
        <li><strong>Tons of Useful Tools:</strong> Linux has many built-in tools that make it easy to work with large data files, such as sorting, searching, and filtering information.</li>
    </ul>
	</section>
	<section id="linux-better">
    <h2>Why Linux is Better Than GUI (Graphical User Interface) Tools</h2>
    <ul>
        <li><strong>Faster and More Efficient:</strong> Linux tools are lightweight, meaning they use less memory and run faster compared to GUI-based tools.</li>
        <li><strong>Automation:</strong> You can write simple scripts to automate repetitive tasks, saving you time when working with big datasets.</li>
        <li><strong>Works Well with Large Datasets:</strong> Linux tools can handle large files without crashing, unlike some GUI tools that may struggle with big data.</li>
        <li><strong>Remote Access:</strong> You can easily access and run tasks on remote computers or servers using Linux, which is especially useful for bioinformatics work.</li>
        <li><strong>Customizable:</strong> You can personalize your Linux setup to make it work just the way you want, allowing you to create custom workflows.</li>
        <li><strong>Can Process Data Faster with Multiple Processors:</strong> Linux supports running tasks on multiple processors at once, which speeds up data analysis, especially for big bioinformatics jobs.</li>
    </ul>

    <h2>In Short:</h2>
    <p>Linux is fast, efficient, and free, making it ideal for bioinformatics work. It lets you process large amounts of data quickly, run tools from anywhere, and automate repetitive tasks‚Äîadvantages that GUI tools can‚Äôt always match.</p>
</section>

	<section id="filesystem">
    <h2>Filesystem Navigation in Linux (via WSL, Linux, or macOS)</h2>
    <p>Understanding how to navigate the file system is essential for working in the Linux terminal. Let‚Äôs go over the fundamental commands used for navigation.</p>

    <h3>1. Key Commands</h3>
    <ul>
        <li><strong><code>pwd</code> (Print Working Directory):</strong>  
            This command shows the <strong>current directory</strong> you are in.
            <pre><code>pwd</code></pre>
            Example output:
            <pre><code>/home/user/Documents</code></pre>
        </li>
        
        <li><strong><code>ls</code> (List):</strong>  
            This command lists all files and directories in the <strong>current directory</strong>.
            <pre><code>ls</code></pre>
            Example output:
            <pre><code>Documents  Pictures  Downloads  Music</code></pre>
            <ul>
                <li>Use <code>ls -l</code> to show detailed information about files.</li>
                <li>Use <code>ls -a</code> to show hidden files (files starting with a dot).</li>
            </ul>
        </li>
        
        <li><strong><code>cd</code> (Change Directory):</strong>  
            This command allows you to <strong>move into a different directory</strong>.
            <pre><code>cd Documents</code></pre>
            This will move you into the <strong>Documents</strong> directory (if it exists in the current directory).
            <ul>
                <li>To go up one level, use <code>cd ..</code>.</li>
            </ul>
        </li>
    </ul>

    <h3>2. Absolute vs. Relative Paths</h3>
    <p>There are two types of paths used for navigation in Linux: <strong>absolute paths</strong> and <strong>relative paths</strong>.</p>
    <ul>
        <li><strong>Absolute Path:</strong> This is the full path to a file or directory, starting from the root directory (<code>/</code>).
            <pre><code>/home/user/Documents</code></pre>
            The absolute path always starts from the root (<code>/</code>), so it is a <strong>complete reference</strong> to the file or directory location.
        </li>
        
        <li><strong>Relative Path:</strong> This refers to a location <strong>relative to the current directory</strong>.
            <pre><code>cd Documents</code></pre>
            If you're currently in the <code>/home/user/</code> directory, this will take you to <code>/home/user/Documents</code>.
            <ul>
                <li>Use <code>cd ..</code> to move to the parent directory.</li>
            </ul>
        </li>
    </ul>

    <h3>3. Example Walkthrough</h3>
    <p>Let‚Äôs assume your file structure looks like this:</p>
    <pre><code>
/home/user/
  ‚îú‚îÄ‚îÄ Documents/
  ‚îú‚îÄ‚îÄ Music/
  ‚îî‚îÄ‚îÄ Pictures/
    </code></pre>

    <ul>
        <li><strong><code>pwd</code></strong> (Print Working Directory):
            If you're currently in the <code>/home/user/</code> directory, typing <code>pwd</code> will display:
            <pre><code>/home/user</code></pre>
        </li>

        <li><strong><code>ls</code></strong> (List Contents):
            To list the contents of <code>/home/user/</code>, type:
            <pre><code>ls</code></pre>
            Output:
            <pre><code>Documents  Music  Pictures</code></pre>
        </li>

        <li><strong><code>cd</code></strong> (Change Directory):
            To move into the <code>Documents</code> directory, type:
            <pre><code>cd Documents</code></pre>
        </li>

        <li><strong><code>pwd</code> again:</strong>
            After changing into the <code>Documents</code> directory, typing <code>pwd</code> again will display:
            <pre><code>/home/user/Documents</code></pre>
        </li>

        <li><strong>Absolute Path Example:</strong>  
            To go to the <code>Music</code> directory from anywhere, you can use the absolute path:
            <pre><code>cd /home/user/Music</code></pre>
        </li>

        <li><strong>Relative Path Example:</strong>
            If you're in the <code>Documents</code> directory and want to move up one level to <code>/home/user/</code>, use:
            <pre><code>cd ..</code></pre>
        </li>
    </ul>

    <h3>4. Activity: Navigate to a Folder and Explore Its Contents</h3>
    <p>Let‚Äôs practice navigating the file system!</p>
    <ol>
        <li><strong>Navigate to a folder:</strong>
            - Open your terminal (WSL/Linux/macOS).
            - Use the <code>pwd</code> command to check your current directory.
            - Use <code>ls</code> to list the contents.
            - Move into a subdirectory using <code>cd <folder_name></code>.
            - Try using both absolute and relative paths.
        </li>

        <li><strong>Explore directory contents:</strong>
            - Use <code>ls -l</code> to list files with details (permissions, file size, etc.).
            - Use <code>ls -a</code> to show hidden files.
            - Use <code>cd ..</code> to go up one level in the directory.
        </li>

        <li><strong>Create a new file and directory:</strong>
            - Create a new directory with:
              <pre><code>mkdir NewFolder</code></pre>
            - Create a new file with:
              <pre><code>touch newfile.txt</code></pre>
            - List the contents with <code>ls</code> to confirm the changes.
        </li>
    </ol>
</section>
<section id="filemanagement">
    <h2>File Management in Linux (via WSL, Linux, or macOS)</h2>
    <p>Understanding file management is crucial for organizing your data and projects. Let‚Äôs cover some essential file management commands in Linux.</p>

    <h3>1. Key File Management Commands</h3>
    <ul>
        <li><strong><code>mkdir</code> (Make Directory):</strong>  
            This command allows you to create a new directory (folder).
            <pre><code>mkdir project_folder</code></pre>
            Example output:
            (No output is returned on success, but the directory is created.)
        </li>

        <li><strong><code>touch</code> (Create Empty File):</strong>  
            This command is used to create an empty file. It can also be used to update the timestamp of an existing file.
            <pre><code>touch newfile.txt</code></pre>
            Example output:
            (No output is returned on success, but the file is created.)
        </li>

        <li><strong><code>cp</code> (Copy Files/Directories):</strong>  
            This command is used to copy files or directories.
            <pre><code>cp file1.txt file2.txt</code></pre>
            This copies `file1.txt` to `file2.txt`.
            <pre><code>cp -r folder1 folder2</code></pre>
            The `-r` option is used to copy directories recursively.
        </li>

        <li><strong><code>mv</code> (Move/Rename Files/Directories):</strong>  
            This command moves or renames files and directories.
            <pre><code>mv oldname.txt newname.txt</code></pre>
            Example: This renames `oldname.txt` to `newname.txt`.
            <pre><code>mv file1.txt /path/to/destination/</code></pre>
            This moves `file1.txt` to a new directory.
        </li>

        <li><strong><code>rm</code> (Remove/Delete Files/Directories):</strong>  
            This command is used to remove files or directories.
            <pre><code>rm file1.txt</code></pre>
            This deletes `file1.txt`. Be cautious as this is permanent.
            <pre><code>rm -r folder1</code></pre>
            The `-r` option allows you to remove directories and their contents recursively.
        </li>
    </ul>

    <h3>2. Creating and Organizing Directories</h3>
    <p>Creating a structured directory system is essential for organizing project files. Here's how you can organize your data:</p>
    
    <ul>
        <li><strong>Creating a new project directory:</strong>
            Use <code>mkdir</code> to create a new directory for your project:
            <pre><code>mkdir my_project</code></pre>
            This will create a directory called `my_project`.
        </li>

        <li><strong>Creating subdirectories:</strong>
            You can create multiple directories within your project folder to keep files organized:
            <pre><code>mkdir my_project/input my_project/output my_project/scripts</code></pre>
            This will create three subdirectories within `my_project` for organizing input data, output files, and scripts.
        </li>

        <li><strong>Creating files inside directories:</strong>
            Once you've set up your directories, you can create files in them using the <code>touch</code> command:
            <pre><code>touch my_project/input/data.txt my_project/scripts/analysis.py</code></pre>
            This will create two files: one in the `input` folder (`data.txt`) and another in the `scripts` folder (`analysis.py`).
        </li>
    </ul>

    <h3>3. Example Walkthrough: Organizing a Project</h3>
    <p>Let's walk through creating a project folder and organizing files:</p>
    <ul>
        <li><strong>Create the project folder:</strong>
            <pre><code>mkdir my_bioinformatics_project</code></pre>
            This creates the main folder for your project.
        </li>

        <li><strong>Create subdirectories:</strong>
            <pre><code>mkdir my_bioinformatics_project/data my_bioinformatics_project/results my_bioinformatics_project/scripts</code></pre>
            This organizes your project into folders for data, results, and scripts.
        </li>

        <li><strong>Create files:</strong>
            <pre><code>touch my_bioinformatics_project/data/input_file.txt</code></pre>
            <pre><code>touch my_bioinformatics_project/scripts/preprocessing.sh</code></pre>
            These files are created inside the appropriate directories.
        </li>

        <li><strong>Copy files into the project folder:</strong>
            <pre><code>cp /path/to/external/input_file.txt my_bioinformatics_project/data/</code></pre>
            This copies an existing file into the `data` directory.
        </li>

        <li><strong>Move files:</strong>
            If you want to reorganize, use <code>mv</code>:
            <pre><code>mv my_bioinformatics_project/scripts/preprocessing.sh my_bioinformatics_project/scripts/analysis.sh</code></pre>
            This renames the `preprocessing.sh` file to `analysis.sh`.
        </li>

        <li><strong>Delete unnecessary files:</strong>
            If a file is no longer needed, use <code>rm</code> to remove it:
            <pre><code>rm my_bioinformatics_project/data/old_data.txt</code></pre>
            This removes the old data file from your project.
        </li>
    </ul>

    <h3>4. Activity: Set Up a Project Folder with Dummy Files</h3>
    <p>Let‚Äôs practice by setting up a project folder and organizing it!</p>
    <ol>
        <li><strong>Create the project directory:</strong>
            - Open your terminal (WSL/Linux/macOS).
            - Run the following command:
            <pre><code>mkdir bioinformatics_project</code></pre>
        </li>

        <li><strong>Create subdirectories for data, scripts, and results:</strong>
            - Create the following directories:
            <pre><code>mkdir bioinformatics_project/data bioinformatics_project/scripts bioinformatics_project/results</code></pre>
        </li>

        <li><strong>Create some files:</strong>
            - Use the <code>touch</code> command to create dummy files:
            <pre><code>touch bioinformatics_project/data/input_file.txt</code></pre>
            <pre><code>touch bioinformatics_project/scripts/analysis.sh</code></pre>
        </li>

        <li><strong>Copy a file into the project:</strong>
            - If you have an existing file (e.g., <code>sample_data.txt</code>), copy it into the project folder:
            <pre><code>cp sample_data.txt bioinformatics_project/data/</code></pre>
        </li>

        <li><strong>Rename a file:</strong>
            - Rename the file `analysis.sh` to `preprocessing.sh`:
            <pre><code>mv bioinformatics_project/scripts/analysis.sh bioinformatics_project/scripts/preprocessing.sh</code></pre>
        </li>

        <li><strong>Delete unnecessary files:</strong>
            - If there are files you no longer need, delete them with <code>rm</code>:
            <pre><code>rm bioinformatics_project/data/old_file.txt</code></pre>
        </li>
    </ol>

    <h3>Expected Outcome:</h3>
    <ul>
        <li>Participants should be able to create directories and organize them into a project folder structure.</li>
        <li>They will practice creating files, copying, renaming, and deleting files within directories.</li>
        <li>By the end of the activity, participants will have set up a simple bioinformatics project structure with dummy files, and they will understand how to manage project files effectively.</li>
    </ul>
</section>
	<section id="viewing">
    <h2>Viewing Files in Linux (via WSL, Linux, or macOS)</h2>
    <p>In bioinformatics, you often deal with large datasets, and knowing how to efficiently view files is crucial. In this section, we will explore several commands that can help you view the contents of files in the terminal.</p>

    <h3>1. Key Commands for Viewing Files</h3>
    <ul>
        <li><strong><code>cat</code> (Concatenate and View File Contents):</strong>
            The <code>cat</code> command is used to display the contents of a file directly in the terminal. It's best used for small files, as it prints the entire file at once.
            <pre><code>cat filename.txt</code></pre>
            Example output:
            <pre><code>Welcome to bioinformatics training.</code></pre>
            <p><strong>Warning:</strong> Avoid using <code>cat</code> for large files, as it may overwhelm the terminal.</p>
        </li>

        <li><strong><code>less</code> (View File Page-by-Page):</strong>
            The <code>less</code> command is useful for viewing large files, as it allows you to scroll through the file one page at a time.
            <pre><code>less filename.txt</code></pre>
            You can navigate using:
            <ul>
                <li><code>Space</code>: Scroll down one page</li>
                <li><code>Up/Down Arrow</code>: Move one line up/down</li>
                <li><code>q</code>: Quit and return to the terminal</li>
            </ul>
        </li>

        <li><strong><code>head</code> (View the First Few Lines of a File):</strong>
            The <code>head</code> command shows the first 10 lines of a file by default. It‚Äôs useful when you want to quickly check the beginning of a large file.
            <pre><code>head filename.txt</code></pre>
            To view a specific number of lines, use the <code>-n</code> option:
            <pre><code>head -n 20 filename.txt</code></pre>
            This shows the first 20 lines of the file.
        </li>

        <li><strong><code>tail</code> (View the Last Few Lines of a File):</strong>
            The <code>tail</code> command is the opposite of <code>head</code>; it shows the last 10 lines of a file by default. It‚Äôs useful for monitoring log files or large datasets where the latest information is more relevant.
            <pre><code>tail filename.txt</code></pre>
            To view the last few lines or monitor a file in real-time, use:
            <pre><code>tail -n 20 filename.txt</code></pre>
            This shows the last 20 lines of the file.
            <pre><code>tail -f filename.txt</code></pre>
            The <code>-f</code> option allows you to follow a file in real-time (useful for logs).
        </li>
    </ul>

    <h3>2. Best Tools for Viewing Large Data Files</h3>
    <p>When working with large data files, it's important to use the right tool to avoid overwhelming your terminal. Here‚Äôs a breakdown of the best tools:</p>
    <ul>
        <li><strong><code>less</code>:</strong> Ideal for viewing large files, as it loads the file one page at a time. You can scroll through the content and search within the file using <code>/search_term</code> and <code>n</code> to go to the next occurrence.</li>
        <li><strong><code>head</code> and <code>tail</code>:</strong> These are best when you only need to view the beginning or the end of the file, respectively. They are more efficient than loading the entire file into the terminal.</li>
        <li><strong><code>cat</code>:</strong> Only recommended for small files, as it prints the entire file to the terminal.</li>
    </ul>

    <h3>3. Example Walkthrough: Viewing Large Files</h3>
    <p>Let‚Äôs walk through the process of using these commands to view a large file, such as a `.txt` or `.tsv` file.</p>

    <ul>
        <li><strong>View a small file using <code>cat</code>:</strong>
            For a small file, simply use:
            <pre><code>cat small_file.txt</code></pre>
            This will display the entire contents of `small_file.txt` at once.
        </li>

        <li><strong>View a large file using <code>less</code>:</strong>
            If the file is large, use:
            <pre><code>less large_file.txt</code></pre>
            This will allow you to scroll through the content one page at a time, making it much easier to navigate large files.
        </li>

        <li><strong>View the first few lines of a file using <code>head</code>:</strong>
            If you only want to check the beginning of the file, use:
            <pre><code>head large_file.txt</code></pre>
            This will show the first 10 lines by default.
        </li>

        <li><strong>View the last few lines of a file using <code>tail</code>:</strong>
            To quickly check the end of a file (e.g., for logs or recent data), use:
            <pre><code>tail large_file.txt</code></pre>
            To monitor the file in real-time (for example, a log file that updates constantly), use:
            <pre><code>tail -f large_file.txt</code></pre>
        </li>
    </ul>

    <h3>4. Activity: Open a `.txt` or `.tsv` File with Each Tool</h3>
    <p>Let's practice opening a file with each tool to better understand their usage and functionality.</p>
    <ol>
        <li><strong>Open a small `.txt` file with <code>cat</code>:</strong>
            - Open a terminal and run:
            <pre><code>cat small_file.txt</code></pre>
            - Verify that the entire file is printed to the terminal.
        </li>

        <li><strong>Open a large `.txt` file with <code>less</code>:</strong>
            - Use <code>less</code> to view a large file:
            <pre><code>less large_file.txt</code></pre>
            - Scroll through the file using the <code>Space</code> key and quit by pressing <code>q</code>.
        </li>

        <li><strong>Open the first 20 lines of a file with <code>head</code>:</strong>
            - Run the following to view the first 20 lines of a file:
            <pre><code>head -n 20 large_file.txt</code></pre>
        </li>

        <li><strong>Open the last 20 lines of a file with <code>tail</code>:</strong>
            - View the last 20 lines of the file:
            <pre><code>tail -n 20 large_file.txt</code></pre>
        </li>

        <li><strong>Monitor a log file with <code>tail -f</code>:</strong>
            - If you have a log file, use:
            <pre><code>tail -f log_file.txt</code></pre>
            - This will allow you to see updates to the log file in real-time.
        </li>
    </ol>

    <h3>Expected Outcome:</h3>
    <ul>
        <li>Participants should be able to efficiently view small and large files using the appropriate commands.</li>
        <li>They will learn how to scroll through large files using <code>less</code>, view the first few lines with <code>head</code>, and view the last few lines with <code>tail</code>.</li>
        <li>By the end of the activity, they should feel comfortable using these commands to handle large datasets or logs in bioinformatics tasks.</li>
    </ul>
</section>
<section id="compressed">
  <h2>üóúÔ∏è Handling Compressed Files</h2>
  <p>Bioinformatics datasets often come as compressed archives. Use the following commands to unpack them:</p>

  <table>
    <thead>
      <tr>
        <th>Command</th>
        <th>Description</th>
        <th>Example</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><code>unzip</code></td>
        <td>Extract files from a <code>.zip</code> archive</td>
        <td><code>unzip samples.zip</code></td>
      </tr>
      <tr>
        <td><code>tar -xvf</code></td>
        <td>Extract contents from a <code>.tar</code> archive</td>
        <td><code>tar -xvf archive.tar</code></td>
      </tr>
      <tr>
        <td><code>tar -xzvf</code></td>
        <td>Extract a <code>.tar.gz</code> (gzip-compressed tar)</td>
        <td><code>tar -xzvf genome.tar.gz</code></td>
      </tr>
      <tr>
        <td><code>tar -xjvf</code></td>
        <td>Extract a <code>.tar.bz2</code> (bzip2-compressed tar)</td>
        <td><code>tar -xjvf data.tar.bz2</code></td>
      </tr>
      <tr>
        <td><code>gunzip</code></td>
        <td>Unzip a single <code>.gz</code> file</td>
        <td><code>gunzip reads.fastq.gz</code></td>
      </tr>
    </tbody>
  </table>

  <h3>üß™ Example Activity</h3>
  <ul>
    <li>Download or provide a file like <code>sample_data.tar.gz</code></li>
    <li>Ask participants to extract it using <code>tar -xzvf sample_data.tar.gz</code></li>
    <li>Use <code>ls</code> to inspect what files were extracted</li>
    <li>Bonus: Ask them to re-compress using <code>tar -czvf new_archive.tar.gz foldername/</code></li>
  </ul>
</section>

<section id="quiz">
  <h2>üìò Linux Terminal Practice: Folder Navigation & File Inspection</h2>
  <p>Use the terminal to complete each task. If the command works, write down the result. If it returns an error, copy the exact error message from your terminal. In some tasks, you‚Äôll be asked what command you would use to achieve a certain outcome.</p>
  <p><strong>üìù Instructions:</strong> Write all your answers in a plain text file named <code>yourLastname_activity1.txt</code>. Once done, submit the file to: <strong>.....</strong>.</p>
  

  <h3>üì¶ Task 0: Extract the training archive</h3>
  <pre><code>unzip bio_training.zip</code></pre>
  <p><strong>Q1:</strong> Did the folder <code>bio_training/</code> get created successfully?</p>
  <p><strong>Q2:</strong> If there was an error, what was the exact message? What command should be use?</p>

  <h3>üîç Task 1: Navigate to a folder</h3>
  <pre><code>cd /bio_training/projectA/data</code></pre>
  <p><strong>Q1:</strong> What are the names of the files in this directory? Use <code>ls</code> to list them.</p>
  <p><strong>Q2:</strong> Did the command work? If not, What should command be use to go to data folder under projectA? </p>

  <h3>üìÑ Task 2: View a file</h3>
  <pre><code>cat exp1.tsv</code></pre>
  <p><strong>Q1:</strong> What is the content of the file? Can you spot the gene with the highest expression?</p>
  <p><strong>Q2:</strong> Did the command work? If not, what exact error message did you see?</p>

  <h3>üìÇ Task 3: Count number of files in a directory</h3>
  <pre><code>ls | wc -l</code></pre>
  <p><strong>Q1:</strong> How many items (files and folders) are listed?</p>
  <p><strong>Q2:</strong> What command would you use to list the actual names instead of just the count?</p>

  <h3>üìú Task 4: Check logs</h3>
  <pre><code>tail -n 1 ../results/error.log</code></pre>
  <p><strong>Q1:</strong> What does the last line of the error log say?</p>
  <p><strong>Q2:</strong> Did the command work? If not, what exact error message did you see?</p>

  <h3>üîç Task 5: Search metadata</h3>
  <pre><code>grep FAIL ../../projectB/metadata/samples.tsv</code></pre>
  <p><strong>Q1:</strong> Which samples failed the quality check?</p>
  <p><strong>Q2:</strong> What command should be used if we want to ignore uppercase/lowercase differences?</p>

  <h3>üî¢ Task 6: Count lines in a log file</h3>
  <pre><code>wc -l ../../projectB/logs/pipeline.log</code></pre>
  <p><strong>Q1:</strong> How many lines are in the log file?</p>
  <p><strong>Q2:</strong> What command would you use to count the number of words instead?</p>

  <h3>üìÅ Task 7: Create a new folder and file</h3>
  <pre><code>mkdir analysis && touch analysis/summary.txt</code></pre>
  <p><strong>Q1:</strong> What command would show the full absolute path of the new file?</p>
  <p><strong>Q2:</strong> What command would you use to confirm that the file is empty?</p>
</section>

	

	
    
  </main>

</body>
</html>
