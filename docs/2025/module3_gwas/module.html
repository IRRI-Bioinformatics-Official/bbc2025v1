<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">

<title>GWAS</title>
<style>
body {
	font-family: Arial, sans-serif;
	margin: 0;
	padding: 0;
	line-height: 1.6;
	display: flex;
	margin-bottom: 100px;
}

html, body {
	height: 100%;
	overflow: auto;
	overscroll-behavior: contain;
}

/* Floating Table of Contents */
#toc {
	position: fixed;
	top: 0px;
	left: 20px;
	width: 200px;
	background-color: #f8f9fa;
	padding: 1rem;
	border-radius: 8px;
	box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
	z-index: 1000;
}

#toc h2 {
	font-size: 1.2rem;
	margin-bottom: 1rem;
}

#toc ul {
	list-style-type: disc;
	font-size: .9rem;
	padding: 0;
}

#toc ul li {
	margin: 0.5rem 0;
}

#toc ul li a {
	text-decoration: none;
	color: #007bff;
}

#toc ul li a:hover {
	text-decoration: underline;
}
/* Main content styling */
main {
	margin-left: 240px; /* Adjusted for TOC width */
	padding: 2rem;
	flex-grow: 1;
}

h1, h2 {
	color: #2c3e50;
}

section {
	margin-bottom: 2rem;
	max-width: 800px;
	padding: 20px;
	background-color: white;
	border-radius: 8px;
	box-shadow: 0 4px 8px rgba(0, 0, 0, 0.1);
}

pre, code {
	background-color: #ededed;
	color: #312f2f;
	padding: 5px 10px;
	border-radius: 4px;
	font-size: .9em;
	font-family: Consolas, monospace;
	overflow-x: auto;
}

code {
	font-size: 1em;
	background-color: #ededed;
	padding: 2px 5px;
	border-radius: 3px;
}

ul {
	list-style-type: disc;
	padding-left: 20px;
}

ul li {
	margin-bottom: 10px;
}

ol {
	padding-left: 20px;
}

li {
	margin-bottom: 10px;
}

strong {
	color: #2c3e50;
}

/* Responsive adjustments */
@media (max-width: 768px) {
  body {
    flex-direction: column;
  }

  #toc {
    position: static;
    width: auto;
    box-shadow: none;
    margin: 1rem;
  }

  main {
    margin-left: 0;
    padding: 1rem;
  }
}

@media (max-width: 480px) {
  #toc h2 {
    font-size: 1rem;
  }

  #toc ul li {
    font-size: 0.85rem;
  }

  section {
    padding: 1rem;
  }

  pre, code {
    font-size: 0.85em;
  }
}



</style>
<script>
  document.addEventListener("DOMContentLoaded", function () {
    const toc = document.getElementById("toc");
    const toggleBtn = document.getElementById("toggleToc");

    function checkScreenWidth() {
      if (window.innerWidth <= 768) {
        toggleBtn.style.display = 'block';
        toc.style.display = 'none';
      } else {
        toggleBtn.style.display = 'none';
        toc.style.display = 'block';
      }
    }

    toggleBtn.addEventListener("click", () => {
      toc.style.display = (toc.style.display === 'none') ? 'block' : 'none';
    });

    window.addEventListener("resize", checkScreenWidth);
    checkScreenWidth();
  });
</script>

</head>
<body>
	<script>
    document.addEventListener("DOMContentLoaded", function () {
      const tocLinks = document.querySelectorAll('#toc a[data-target]');
      tocLinks.forEach(link => {
        link.addEventListener('click', function (e) {
          e.preventDefault();
          const targetId = this.getAttribute('data-target');
          const targetElement = document.getElementById(targetId);
          if (targetElement) {
            targetElement.scrollIntoView({ behavior: 'smooth', block: 'start' });
          }
        });
      });
    });
  </script>
	<!-- Floating Table of Contents -->
	<div id="toc">
		<h2>Outline:</h2>
		<ul>
			<li><a href="#" data-target="overview">I. Overview</a></li>
			<li><a href="#" data-target="intro">II. Introduction</a></li>
			<li><a href="#" data-target="data-prep">III. GWAS Data Preparation</a></li>
			<li><a href="#" data-target="tassel">IV. TASSEL GWAS Workflow</a></li>
			<li><a href="#" data-target="tassel">V. Basic GWAS</a></li>
			<!-- <li><a href="#" data-target="os">I. Operating Systems</a></li>
			<li><a href="#" data-target="why-linux">II. Why Linux is
					Important in Bioinformatics</a></li>
			<li><a href="#" data-target="linux-better">III. Why Linux is
					Better Than GUI (Graphical User Interface) Tools</a></li>
			<li><a href="#" data-target="filesystem">IV. Filesystem
					Navigation </a></li>
			<li><a href="#" data-target="filemanagement">V. File
					Management</a></li>
			<li><a href="#" data-target="viewing">VI. Viewing Files in
					Linux</a></li>
			<li><a href="#" data-target="compressed">VII. Handling
					Compressed File</a></li>
			<li><a href="#" data-target="quiz">VIII. Activity</a></li>
			 -->
			<li><a
				href="main_c.html"
				target="blank">IX. Cheat Sheet</a></li>
		</ul>
	</div>


	<!-- Main Content -->
	<main style="margin-bottom: 100px;margin-top:20px;">
		<button id="toggleToc" style="display: none;">‚ò∞ Table of Contents</button>
		
		<section id="overview">
			<h1 style="text-align: center !important; font-size:175%">Genome-wide Association Studies (GWAS)</h1>
		<!--	<h3>üéØ Topic</h3>
			<p>Linux Basics, Filesystem, and Shell Navigation</p>

			<h3>üë• Target Audience</h3>
			<p>Beginners in bioinformatics ‚Äî no prior Linux experience
				required.</p>
		-->
			<h3>Goal</h3>
			<p>In this module, you'll learn the basics of analyzing Genome-Wide Association Studies (GWAS) data.
			We'll start by looking at the fundamentals of GWAS and understanding the data they produce.
			Then, we'll examine how to identify genetic variants associated with traits or diseases in a population.
			We'll also cover how to ensure the quality of our data, filter out any errors, and perform statistical analyses to interpret
			what our GWAS data is revealing about genetic associations.
			</p>
		</section>

		<section id="intro">
			<h2>Introduction to GWAS</h2>

			<h3>Fundamental concepts of GWAS</h3>
			<p>Genome-Wide Association Studies (GWAS)  are methods used to identify genetic variants associated with a trait of interest  by scanning markers across large  sets of individual genomes,
				to determine if any genetic variations are associated with a specific disease or trait.
				<br>
				Overall GWAS procedure:
				<ol>
					<li>Select the GWAS panel - a collection of accessions that can be thought of as a sample from a population (or represent diverse gene pool)</li>
					<li>Genotype or sequence all the accessions in the panel</li>
					<li>Phenotype the accessions for a trait (or traits)  of interest</li>
					<li>Run the association analysis following one of GWAS approaches.</li>
				</ol>

				In this course we will mainly focus on step 4, i.e. assume that the panel is already selected, genotyped, and phenotyped. 
				We will briefly touch step 1 in the end when discussing the power of GWAS.
			</p>

			<h3>Goal</h3>
			<p>
				Our goal is to understand the relationship between genotype and phenotype. <br> Phenotype can most generally be modeled as:<br>
					<p style="text-align: center;">	Pheno=ùëì(Geno)+ùëí </p> <br>
				where ùëí  represents the noise or error from non-genetic factors. To proceed anywhere, we need to make some simplifying assumptions.	
			</p>
			<h3>Common Assumptions</h3>
			<p>
				<ol>
					<li>The trait is influenced by a few variants with significant effects, or</li>
					<li>The trait is influenced by many variants, each with a small effect.</li>
				</ol>


				These effects are typically assumed to be additive and independent, leading to a linear model:
					<p style="text-align: center;"> Y = + SNP1 *1+ SNP2*2 +  + SNPM*M </p> <br>
				where Y is the phenotype, mu is the phenotype mean, M is the number of SNPs or genetic markers in the model,
				SNP_1 to SNP_M are encoded genotype values for each SNP (more on this later,
				in the simplest case these are 0-1 variables), and beta_1 to beta_M are corresponding effects.
			</p>
			<h3>Issues with simple linear models</h3>
			<p>
				The trouble with the model above is that in a typical situation the number of samples is much  less than the number of SNPs.
				This implies that the model lacks a unique solution, making SNP effects indeterminable.
				There are several ways out of this. The most typical way is trying to test a single SNP at a time, scanning all the SNPs in the genome in turn.
			</p>
			<h3>Single-SNP GWAS</h3>
			<p>
			The typical procedure is to test each SNP for association with the phenotype:
				<ul>
					<li>Detects considerable effects on the trait.</li>
					<li>Focuses on identifying regions affecting the phenotype rather than creating a comprehensive model.</li>
					<li>Relies on linkage disequilibrium (LD) to capture variants not in the dataset.</li>
				</ul>
			</p>
			<h3>Models for Genotype-Phenotype Association</h3>
			<ol>
				<li>Single-SNP: Testing each SNP individually.<br>This is the most typical approach.</li>
				<li>Multiple SNP: Using multiple SNPs simultaneously.<br>Several methods have been developed (e.g. FarmCPU, BLINK etc) that produce a multiple-SNP final model.</li>
				<li>Whole-genome: Incorporating all SNPs.<br>As we noted above, such a problem does not have a solution within the ordinary linear regression model (ordinary least squares). However, there are many penalized regression methods that allow more variables than observations and are applied to GWAS datasets.</li>
			</ol>
			<h3>Testing for association in a single-Marker GWAS</h3>
			<p>
				How do we test association between phenotype and genotype (single SNP)? 
				There are many statistical tests developed for testing association or non-independence.
				First, let us understand what variables we are dealing with.
				<br>
				<br>
				In diploid species, a biallelic SNP genotype can look like this
				<ul>
					<li>Sample1 AA</li>
					<li>Sample2 GG</li>
					<li>Sample3 AG</li>
					<li>...</li>
					<li>Sample400 AA</li>
				</ul>
				In this example the SNP has two alleles, A and G, and because the organism is diploid, the genotypes contain two alleles.
				Thus, the genotypes are AA, AG, and GG. (We don't distinguish between AG and GA).
				<br>
				Most of the SNPs are biallelic (have only two alleles). In this course we deal with diploid species only (rice).
				There are wild relatives of rice that are tetraploid, and the theory would be slightly different for those species.
				<br>
				A biallelic SNP genotype is a categorical variable with 3 levels:
					<ul>
						<li>homozygous reference</li>
						<li>heterozygous</li>
						<li>homozygous alternate allele</li>
					</ul>
				These levels can be coded numerically as 0,1,2.
				<br>
				<br>
				On the phenotype side, there are different types of phenotypes. 
				Some are quantitative (plant height, cm; weight, g; days to flowering);
				Some are categorical: resistant vs susceptible, tolerant  vs intolerant; seed color can be white, red, or purple. 
				<br>
				Depending on how we model both phenotype and genotype, we can select various association tests.
				There are
					<ul>
						<li>e.g. for binary traits we can employ: a chi-squared test or use  logistic regression.</li>
						<li>For continuous traits: t-test, linear regression.</li>
					</ul>
				Below we assume quantitative phenotype.
				<br>
				For a biallelic SNP genotype (AA, Aa, aa), the encoding is 0, 1, 2 based on the number of minor alleles.	
			</p>
		</section>
		<section id="data-prep">
			<h2>GWAS Data preparation</h2>
			<p>
			In order to understand the principles behind the data preparation best practices, we need to understand how the genotype datasets are created.
			</p>
			<h3>Dense Genotype Datasets</h3>
			<p>
			Diversity panels genotyped with whole-genome sequencing often exhibit:
				<ul>
					<li>A large number of SNPs, many of which are rare.</li>
					<li>Extensive LD between SNPs, influenced by evolutionary patterns such as bottlenecks, selection, and population stratification.</li>
				</ul>
			</p>
			<h3>SNP Filtering</h3>
			<ul>
				<li>Minor Allele Frequency (MAF) thresholds are typically set at
					<ul>
						<li>maf > 0.05 for n=300 and below</li>
						<li>maf > 0.01 for n >1000 and above</li>
						<li>one may exercise some freedom here</li>
					</ul>
				</li>	
				<li>Missing Data: High missing call rates reduce reliability; imputation may be used cautiously.</li>
				<li>Hardy-Weinberg Equilibrium (HWE): Adjustments are necessary for inbred or partially selfing species.</li>
			</ul>
			<h3>Phenotype Data Preparation</h3>
			<ul>
				<li>Adjust raw phenotype data, identify and handle outliers.</li>
				<li>Ensure phenotype normality for standard modeling assumptions, though models with covariates do not require normality of the phenotype itself.</li>
			</ul>
			<h3>Linkage Disequilibrium (LD) in GWAS</h3>
			<p>
			LD allows for the detection of non genotyped variants and influences the association signals:
				<ul>
					<li>Strong LD leads to wider association peaks and can obscure causal variants.</li>
					<li>Imputation methods can leverage LD to infer missing genotypes or untyped variants.</li>
				</ul>
			</p>
			<h3>Peak Analysis</h3>
			<ul>
				<li>Analyzing haplotype groupings in regions with significant association peaks to understand the underlying genetic architecture.</li>
			</ul>
		</section>
		
		<section id="tassel">
			<h1 style="text-align: center !important; font-size:175%">Introduction to TASSEL GWAS Workflow</h1>
			<h3>Overview</h3>
			<p>In this hands-on module you will conduct a basic GWAS workflow in TASSEL, from loading and examining input data, running the necessary analyses, to creating Manhattan and QQ plots.
				In this workflow we use one of the simplest models implemented in TASSEL (general linear model).  Later we will discuss how this workflow can be improved to meet various challenges.
			</p>
			<h3>Loading Data</h3>
			<p>
			For GWAS analysis you need, at a minimum, the following types of inputs:
			<br>
			Inputs:
				<ul>
					<li>A genotype file in PED/MAP, VCF, or HapMap format</li>
					<li>A phenotype file formatted for TASSEL</li>
					<img border="0" width="215" height="190" src="m3files/Picture1.png" v:shapes="_x0000_i1034">
				</ul>
				
			</p>
			<p>
			For this exercise, we will use the following files:
				<ul>
					<li>Genotype in PLINK (PED/MAP) format:</li>
						<ul>
							<li style="font-family: Courier New;">LD_pruned.ped</li>
							<li style="font-family: Courier New;">LD_pruned.map</li>
						</ul>
					<li>Phenotype file:</li>
						<ul>
							<li style="font-family: Courier New;">pheno-tassel.txt</li>
						</ul>
				</ul>
			</p>
			<h3>SNP Data</h3>
			<p>Loading SNP data allows you to visualize and explore genetic variations across your samples.
			Understanding these variations is fundamental to identifying associations between genetic markers and traits of interest.
			</p>
			<ol>
				<li>In the top menu, click <span style="font-family: Courier New;">File -> Open As</span> and select <span style="font-family: Courier New;">Plink</span>.</li>
				<img border="0" width="304" height="138" src="m3files/Picture2.png" v:shapes="_x0000_i1034">
				<li>Select the PED and MAP files (<span style="font-family: Courier New;">LDpruned.ped</span> and <span style="font-family: Courier New;">LDpruned.map</span>)</li>
				<img border="0" width="304" height="140" src="m3files/Picture3.png" v:shapes="_x0000_i1034">
				<li>Upon successful loading, a new dataset will appear in the "Sequence" folder.</li>
				<img border="0" width="126" height="44" src="m3files/Picture4.png" v:shapes="_x0000_i1034">
			</ol>
			<h3>Loaded SNP data</h3>
			<ul>
				<li>Once the genotype (SNP) data is loaded, you will see a summary of the dataset on the left side, which looks as follows:</li>
				<img border="0" width="309" height="194" src="m3files/Picture5.png" v:shapes="_x0000_i1034">
				<li>The graphical genotype view will show a portion of your genotype data.</li>
				<img border="0" width="767" height="350" src="m3files/Picture6.png" v:shapes="_x0000_i1034">
				<br>	
			You may scroll up and down to change the visible samples, and use the slider to change the genomic region.
			The dropdown currently showing "MajorMinorAllele" shows the coloring scheme. The default scheme shown here colors the genotype calls as follows:
				<ul>
					<li>Homozygous REFerence : yellow</li>
					<li>Heterozygous: dark green</li>
					<li>Homozygous ALTernate: blue</li>
					<li>Missing call (N): white</li>
				</ul>
			</ul>

			<h3>Load Phenotype</h3>
			<p>
			TASSEL supports loading phenotype files in specific format (see above). The file may contain several traits, making it easier to run GWAS on multiple traits.
			<ul>
				<li>File -> Open As -> Phenotype (scroll the options list down)</li>
				<img border="0" width="309" height="144" src="m3files/Picture7.png" v:shapes="_x0000_i1034">
				<li>Choose a phenotype file. Upon loading, the data panel will look like</li>
				<img border="0" width="421" height="825" src="m3files/Picture8.png" v:shapes="_x0000_i1034">
			</ul>	
			</p>
		</section>
		
		<section id="basic-gwas">
			<h2>BASIC GWAS</h2>
			<h3>Join Genotype and Phenotype:</h3>
			<p>
			This step ensures matching of samples between phenotype and genotype datasets.
			<ol>
				<li>Select both genotype and phenotype files.</li>
				<li>Click <span style="font-family: Courier New;">Data -> Intersect Join</span></li>
				<li>
				A simple association test (GLM, No Covariates):
					<ol>
						<li>Select the intersect dataset (geno+pheno).</li>
						<li>Click <span style="font-family: Courier New;">Analysis -> Association -> GLM</span>.</li>
						<li>Leave the default choices and proceed.</li>
						<img border="0" width="468" height="210" src="m3files/Picture9.png" v:shapes="_x0000_i1034">
						<br>
						<img border="0" width="468" height="191" src="m3files/Picture10.png" v:shapes="_x0000_i1034">
						<br>
						<li>Leave the default choices and proceed.</li>
						<img border="0" width="338" height="167" src="m3files/Picture12.png" v:shapes="_x0000_i1034">
						<img border="0" width="338" height="167" src="m3files/Picture13.png" v:shapes="_x0000_i1034">
						<br>
						<li>When the GWAS run finishes, the Results pane will contain an Association section:</li>
						<img border="0" width="338" height="167" src="m3files/Picture14.png" v:shapes="_x0000_i1034">
						<li>Finding Results Table</li>
						<img border="0" width="468" height="191" src="m3files/Picture15.png" v:shapes="_x0000_i1034">
					</ol>
				</li>
			</ol>
			<strong>Note on file saving</strong>
			<ol>
				<li>In the GLM setup screen, you may check the "Save to file" checkbox and choose the output file location. 
					Note that there are two output tables: Statistics file (this will contain p-values) and Effects file (this will hold estimated SNP effects).</li>
				<li>Alternatively, after the computation finished within TASSEL, use <span style="font-family: Courier New;">File-> Save as</span>.</li>
				<img border="0" width="268" height="323" src="m3files/Picture13.png" v:shapes="_x0000_i1034">
			</ol>
			<strong>Results table can be sorted by columns</strong>
			Find variants with smallest p-value - click on column header of the (p) column
			<br>
			Notable columns:
			<ul>
				<li>
					p, add_p, dom_p (p-values of the three genotype models)
					<ul>
						<li>add_p holds the p-value from the most common genotype association model (additive)</li>
						<li>dom_p: dominance model (both heterozygous and HOM ALT calls assumed to have  the same effect).</li>
					</u>

				</li>
				<li>marker R squared
					<ul>
						<li>This is a common population-weighted measure of SNP effect. It generally does not replicate across different populations.</li>
					</ul>
				</li>
				<li>minorObs</li>
				<img border="0" width="468" height="65" src="m3files/Picture17.png" v:shapes="_x0000_i1034">
				<li>Note the frequencies of these SNPs (last column: # minor Obs) and marker R2</li>
				<img border="0" width="101" height="132" src="m3files/Picture18.png" v:shapes="_x0000_i1034">
				<li>Don't forget this is a basic model that completely ignores population structure.
				Before digging deep into the table, let's visualize results and do a simple QC using a Q-Q plot.</li>		
			</ul>
			

			</p>
			
		</section>
		<!--  
		<section id="os">
			<h2>Understanding Operating Systems for Bioinformatics</h2>
			<p>
				When working with bioinformatics tools, it's essential to understand
				the differences between operating systems (OS) like <strong>Windows</strong>,
				<strong>Linux</strong>, and <strong>macOS</strong>, as well as how
				to bridge the gap between them using tools like <strong>WSL
					(Windows Subsystem for Linux)</strong>.
			</p>

			<h3>1. Windows vs. Linux vs. macOS</h3>
			<ul>
				<li><strong>Windows</strong> is a popular OS for general use
					and is often used in corporate environments. While it has GUI-based
					tools, it can be limiting when working with command-line-heavy
					bioinformatics workflows. Many bioinformatics tools are not
					natively supported on Windows, requiring workarounds like WSL or
					virtual machines.</li>
				<li><strong>Linux</strong> is the preferred OS for
					bioinformatics because it offers superior performance, stability,
					and extensive command-line tools designed specifically for
					computational tasks and data analysis. Most bioinformatics software
					is optimized for Linux.</li>
				<li><strong>macOS</strong> is similar to Linux in terms of
					underlying architecture (both are Unix-based), so many
					bioinformatics tools that run on Linux can also run on macOS. It's
					often preferred by researchers who need a balance of ease of use
					(macOS GUI) and command-line functionality. It offers strong
					support for development environments and bioinformatics software,
					though some specialized Linux tools might require additional setup.</li>
			</ul>

			<h3>2. Windows Subsystem for Linux (WSL)</h3>
			<ul>
				<li><strong>WSL</strong> allows Windows users to run a Linux
					environment directly on top of Windows without the need for
					dual-booting or using virtual machines.</li>
				<li>WSL provides a full Linux kernel, enabling users to install
					and run popular bioinformatics tools that are typically only
					available on Linux.</li>
				<li><strong>Advantages of WSL:</strong></li>
				<ul>
					<li>Easy access to both Windows and Linux tools in one
						environment.</li>
					<li>Ideal for Windows users who need to run Linux tools
						without switching OS.</li>
					<li>Access to the Linux file system and native Linux utilities
						directly from Windows.</li>
				</ul>
				<li><strong>Limitations of WSL:</strong></li>
				<ul>
					<li>Some high-performance tools might not run as efficiently
						as on a full Linux system.</li>
					<li>While WSL 2 supports a full Linux kernel, it still
						operates within Windows, which could affect performance with very
						large datasets or computationally intensive tasks.</li>
				</ul>
			</ul>

			<h3>3. Choosing the Right OS for Your Work</h3>
			<ul>
				<li><strong>Linux</strong> is the best option for
					bioinformatics work, as it provides the best performance,
					efficiency, and native support for bioinformatics tools.</li>
				<li><strong>macOS</strong> is a good alternative if you need
					the Unix environment but prefer a more user-friendly GUI. It‚Äôs
					compatible with most bioinformatics tools and is widely used by
					researchers who prefer working with a Mac.</li>
				<li><strong>Windows</strong> is less ideal for bioinformatics
					but can be used effectively with tools like WSL to run Linux-based
					tools without switching OSs.</li>
				<li>If you‚Äôre a Windows user and need Linux tools, <strong>WSL</strong>
					is a great option to get the Linux environment without leaving
					Windows.
				</li>
				<li>For macOS users, using a native Unix-based environment
					makes it easy to run bioinformatics tools, but certain specialized
					Linux tools might require additional setup or a virtual machine.</li>
			</ul>
		</section>

		<section id="why-linux">
			<h2>Why Linux is Important in Bioinformatics</h2>
			<ul>
				<li><strong>Most Bioinformatics Tools Are Built for
						Linux:</strong> Many tools used in bioinformatics, like those for gene
					analysis and sequencing, work best on Linux systems.</li>
				<li><strong>Free and Open Source:</strong> Linux is free to
					use, and bioinformatics software is often open-source, meaning
					anyone can use, modify, and share it.</li>
				<li><strong>Handles Large Data Efficiently:</strong>
					Bioinformatics involves working with huge data files (like genome
					data). Linux is good at managing and processing large amounts of
					data quickly.</li>
				<li><strong>Works Well with High-Performance
						Computers:</strong> Many research labs use powerful Linux-based computers
					(called clusters) to analyze data faster.</li>
				<li><strong>Tons of Useful Tools:</strong> Linux has many
					built-in tools that make it easy to work with large data files,
					such as sorting, searching, and filtering information.</li>
			</ul>
		</section>
		<section id="linux-better">
			<h2>Why Linux is Better Than GUI (Graphical User Interface)
				Tools</h2>
			<ul>
				<li><strong>Faster and More Efficient:</strong> Linux tools are
					lightweight, meaning they use less memory and run faster compared
					to GUI-based tools.</li>
				<li><strong>Automation:</strong> You can write simple scripts
					to automate repetitive tasks, saving you time when working with big
					datasets.</li>
				<li><strong>Works Well with Large Datasets:</strong> Linux
					tools can handle large files without crashing, unlike some GUI
					tools that may struggle with big data.</li>
				<li><strong>Remote Access:</strong> You can easily access and
					run tasks on remote computers or servers using Linux, which is
					especially useful for bioinformatics work.</li>
				<li><strong>Customizable:</strong> You can personalize your
					Linux setup to make it work just the way you want, allowing you to
					create custom workflows.</li>
				<li><strong>Can Process Data Faster with Multiple
						Processors:</strong> Linux supports running tasks on multiple processors at
					once, which speeds up data analysis, especially for big
					bioinformatics jobs.</li>
			</ul>

			<h2>In Short:</h2>
			<p>Linux is fast, efficient, and free, making it ideal for
				bioinformatics work. It lets you process large amounts of data
				quickly, run tools from anywhere, and automate repetitive
				tasks‚Äîadvantages that GUI tools can‚Äôt always match.</p>
		</section>

		<section id="filesystem">
			<h2>Filesystem Navigation in Linux (via WSL, Linux, or macOS)</h2>
			<p>Understanding how to navigate the file system is essential for
				working in the Linux terminal. Let‚Äôs go over the fundamental
				commands used for navigation.</p>

			<h3>1. Key Commands</h3>
			<ul>
				<li><strong><code>pwd</code> (Print Working
						Directory):</strong> This command shows the <strong>current
						directory</strong> you are in. <pre>
						<code>pwd</code>
					</pre> Example output: <pre>
						<code>/home/user/Documents</code>
					</pre></li>

				<li><strong><code>ls</code> (List):</strong> This command lists
					all files and directories in the <strong>current directory</strong>.
					<pre>
						<code>ls</code>
					</pre> Example output: <pre>
						<code>Documents  Pictures  Downloads  Music</code>
					</pre>
					<ul>
						<li>Use <code>ls -l</code> to show detailed information about
							files.
						</li>
						<li>Use <code>ls -a</code> to show hidden files (files
							starting with a dot).
						</li>
					</ul></li>

				<li><strong><code>cd</code> (Change Directory):</strong> This
					command allows you to <strong>move into a different
						directory</strong>. <pre>
						<code>cd Documents</code>
					</pre> This will move you into the <strong>Documents</strong> directory
					(if it exists in the current directory).
					<ul>
						<li>To go up one level, use <code>cd ..</code>.
						</li>
					</ul></li>
			</ul>

			<h3>2. Absolute vs. Relative Paths</h3>
			<p>
				There are two types of paths used for navigation in Linux: <strong>absolute
					paths</strong> and <strong>relative paths</strong>.
			</p>
			<ul>
				<li><strong>Absolute Path:</strong> This is the full path to a
					file or directory, starting from the root directory (<code>/</code>).
					<pre>
						<code>/home/user/Documents</code>
					</pre> The absolute path always starts from the root (<code>/</code>), so
					it is a <strong>complete reference</strong> to the file or
					directory location.</li>

				<li><strong>Relative Path:</strong> This refers to a location <strong>relative
						to the current directory</strong>. <pre>
						<code>cd Documents</code>
					</pre> If you're currently in the <code>/home/user/</code> directory,
					this will take you to <code>/home/user/Documents</code>.
					<ul>
						<li>Use <code>cd ..</code> to move to the parent directory.
						</li>
					</ul></li>
			</ul>

			<h3>3. Example Walkthrough</h3>
			<p>Let‚Äôs assume your file structure looks like this:</p>
			<pre>
				<code>
/home/user/
  ‚îú‚îÄ‚îÄ Documents/
  ‚îú‚îÄ‚îÄ Music/
  ‚îî‚îÄ‚îÄ Pictures/
    </code>
			</pre>

			<ul>
				<li><strong><code>pwd</code></strong> (Print Working
					Directory): If you're currently in the <code>/home/user/</code>
					directory, typing <code>pwd</code> will display: <pre>
						<code>/home/user</code>
					</pre></li>

				<li><strong><code>ls</code></strong> (List Contents): To list
					the contents of <code>/home/user/</code>, type: <pre>
						<code>ls</code>
					</pre> Output: <pre>
						<code>Documents  Music  Pictures</code>
					</pre></li>

				<li><strong><code>cd</code></strong> (Change Directory): To
					move into the <code>Documents</code> directory, type: <pre>
						<code>cd Documents</code>
					</pre></li>

				<li><strong><code>pwd</code> again:</strong> After changing
					into the <code>Documents</code> directory, typing <code>pwd</code>
					again will display: <pre>
						<code>/home/user/Documents</code>
					</pre></li>

				<li><strong>Absolute Path Example:</strong> To go to the <code>Music</code>
					directory from anywhere, you can use the absolute path: <pre>
						<code>cd /home/user/Music</code>
					</pre></li>

				<li><strong>Relative Path Example:</strong> If you're in the <code>Documents</code>
					directory and want to move up one level to <code>/home/user/</code>,
					use: <pre>
						<code>cd ..</code>
					</pre></li>
			</ul>

			<h3>4. Activity: Navigate to a Folder and Explore Its Contents</h3>
			<p>Let‚Äôs practice navigating the file system!</p>
			<ol>
				<li><strong>Navigate to a folder:</strong> - Open your terminal
					(WSL/Linux/macOS). - Use the <code>pwd</code> command to check your
					current directory. - Use <code>ls</code> to list the contents. -
					Move into a subdirectory using <code>
						cd
						<folder_name>
					</code>. - Try using both absolute and relative paths.</li>

				<li><strong>Explore directory contents:</strong> - Use <code>ls
						-l</code> to list files with details (permissions, file size, etc.). -
					Use <code>ls -a</code> to show hidden files. - Use <code>cd
						..</code> to go up one level in the directory.</li>

				<li><strong>Create a new file and directory:</strong> - Create
					a new directory with: <pre>
						<code>mkdir NewFolder</code>
					</pre> - Create a new file with: <pre>
						<code>touch newfile.txt</code>
					</pre> - List the contents with <code>ls</code> to confirm the changes.</li>
			</ol>
		</section>
		<section id="filemanagement">
			<h2>File Management in Linux (via WSL, Linux, or macOS)</h2>
			<p>Understanding file management is crucial for organizing your
				data and projects. Let‚Äôs cover some essential file management
				commands in Linux.</p>

			<h3>1. Key File Management Commands</h3>
			<ul>
				<li><strong><code>mkdir</code> (Make Directory):</strong> This
					command allows you to create a new directory (folder). <pre>
						<code>mkdir project_folder</code>
					</pre> Example output: (No output is returned on success, but the
					directory is created.)</li>

				<li><strong><code>touch</code> (Create Empty File):</strong>
					This command is used to create an empty file. It can also be used
					to update the timestamp of an existing file. <pre>
						<code>touch newfile.txt</code>
					</pre> Example output: (No output is returned on success, but the file is
					created.)</li>

				<li><strong><code>cp</code> (Copy Files/Directories):</strong>
					This command is used to copy files or directories. <pre>
						<code>cp file1.txt file2.txt</code>
					</pre> This copies `file1.txt` to `file2.txt`. <pre>
						<code>cp -r folder1 folder2</code>
					</pre> The `-r` option is used to copy directories recursively.</li>

				<li><strong><code>mv</code> (Move/Rename
						Files/Directories):</strong> This command moves or renames files and
					directories. <pre>
						<code>mv oldname.txt newname.txt</code>
					</pre> Example: This renames `oldname.txt` to `newname.txt`. <pre>
						<code>mv file1.txt /path/to/destination/</code>
					</pre> This moves `file1.txt` to a new directory.</li>

				<li><strong><code>rm</code> (Remove/Delete
						Files/Directories):</strong> This command is used to remove files or
					directories. <pre>
						<code>rm file1.txt</code>
					</pre> This deletes `file1.txt`. Be cautious as this is permanent. <pre>
						<code>rm -r folder1</code>
					</pre> The `-r` option allows you to remove directories and their
					contents recursively.</li>
			</ul>

			<h3>2. Creating and Organizing Directories</h3>
			<p>Creating a structured directory system is essential for
				organizing project files. Here's how you can organize your data:</p>

			<ul>
				<li><strong>Creating a new project directory:</strong> Use <code>mkdir</code>
					to create a new directory for your project: <pre>
						<code>mkdir my_project</code>
					</pre> This will create a directory called `my_project`.</li>

				<li><strong>Creating subdirectories:</strong> You can create
					multiple directories within your project folder to keep files
					organized: <pre>
						<code>mkdir my_project/input my_project/output my_project/scripts</code>
					</pre> This will create three subdirectories within `my_project` for
					organizing input data, output files, and scripts.</li>

				<li><strong>Creating files inside directories:</strong> Once
					you've set up your directories, you can create files in them using
					the <code>touch</code> command: <pre>
						<code>touch my_project/input/data.txt my_project/scripts/analysis.py</code>
					</pre> This will create two files: one in the `input` folder (`data.txt`)
					and another in the `scripts` folder (`analysis.py`).</li>
			</ul>

			<h3>3. Example Walkthrough: Organizing a Project</h3>
			<p>Let's walk through creating a project folder and organizing
				files:</p>
			<ul>
				<li><strong>Create the project folder:</strong> <pre>
						<code>mkdir my_bioinformatics_project</code>
					</pre> This creates the main folder for your project.</li>

				<li><strong>Create subdirectories:</strong> <pre>
						<code>mkdir my_bioinformatics_project/data my_bioinformatics_project/results my_bioinformatics_project/scripts</code>
					</pre> This organizes your project into folders for data, results, and
					scripts.</li>

				<li><strong>Create files:</strong> <pre>
						<code>touch my_bioinformatics_project/data/input_file.txt</code>
					</pre> <pre>
						<code>touch my_bioinformatics_project/scripts/preprocessing.sh</code>
					</pre> These files are created inside the appropriate directories.</li>

				<li><strong>Copy files into the project folder:</strong> <pre>
						<code>cp /path/to/external/input_file.txt my_bioinformatics_project/data/</code>
					</pre> This copies an existing file into the `data` directory.</li>

				<li><strong>Move files:</strong> If you want to reorganize, use
					<code>mv</code>: <pre>
						<code>mv my_bioinformatics_project/scripts/preprocessing.sh my_bioinformatics_project/scripts/analysis.sh</code>
					</pre> This renames the `preprocessing.sh` file to `analysis.sh`.</li>

				<li><strong>Delete unnecessary files:</strong> If a file is no
					longer needed, use <code>rm</code> to remove it: <pre>
						<code>rm my_bioinformatics_project/data/old_data.txt</code>
					</pre> This removes the old data file from your project.</li>
			</ul>

			<h3>4. Activity: Set Up a Project Folder with Dummy Files</h3>
			<p>Let‚Äôs practice by setting up a project folder and organizing
				it!</p>
			<ol>
				<li><strong>Create the project directory:</strong> - Open your
					terminal (WSL/Linux/macOS). - Run the following command: <pre>
						<code>mkdir bioinformatics_project</code>
					</pre></li>

				<li><strong>Create subdirectories for data, scripts,
						and results:</strong> - Create the following directories: <pre>
						<code>mkdir bioinformatics_project/data bioinformatics_project/scripts bioinformatics_project/results</code>
					</pre></li>

				<li><strong>Create some files:</strong> - Use the <code>touch</code>
					command to create dummy files: <pre>
						<code>touch bioinformatics_project/data/input_file.txt</code>
					</pre> <pre>
						<code>touch bioinformatics_project/scripts/analysis.sh</code>
					</pre></li>

				<li><strong>Copy a file into the project:</strong> - If you
					have an existing file (e.g., <code>sample_data.txt</code>), copy it
					into the project folder: <pre>
						<code>cp sample_data.txt bioinformatics_project/data/</code>
					</pre></li>

				<li><strong>Rename a file:</strong> - Rename the file
					`analysis.sh` to `preprocessing.sh`: <pre>
						<code>mv bioinformatics_project/scripts/analysis.sh bioinformatics_project/scripts/preprocessing.sh</code>
					</pre></li>

				<li><strong>Delete unnecessary files:</strong> - If there are
					files you no longer need, delete them with <code>rm</code>: <pre>
						<code>rm bioinformatics_project/data/old_file.txt</code>
					</pre></li>
			</ol>

		
		</section>
		<section id="viewing">
			<h2>Viewing Files in Linux (via WSL, Linux, or macOS)</h2>
			<p>In bioinformatics, you often deal with large datasets, and
				knowing how to efficiently view files is crucial. In this section,
				we will explore several commands that can help you view the contents
				of files in the terminal.</p>

			<h3>1. Key Commands for Viewing Files</h3>
			<ul>
				<li><strong><code>cat</code> (Concatenate and View
						File Contents):</strong> The <code>cat</code> command is used to display
					the contents of a file directly in the terminal. It's best used for
					small files, as it prints the entire file at once. <pre>
						<code>cat filename.txt</code>
					</pre> Example output: <pre>
						<code>Welcome to bioinformatics training.</code>
					</pre>
					<p>
						<strong>Warning:</strong> Avoid using
						<code>cat</code>
						for large files, as it may overwhelm the terminal.
					</p></li>

				<li><strong><code>less</code> (View File
						Page-by-Page):</strong> The <code>less</code> command is useful for viewing
					large files, as it allows you to scroll through the file one page
					at a time. <pre>
						<code>less filename.txt</code>
					</pre> You can navigate using:
					<ul>
						<li><code>Space</code>: Scroll down one page</li>
						<li><code>Up/Down Arrow</code>: Move one line up/down</li>
						<li><code>q</code>: Quit and return to the terminal</li>
					</ul></li>

				<li><strong><code>head</code> (View the First Few
						Lines of a File):</strong> The <code>head</code> command shows the first 10
					lines of a file by default. It‚Äôs useful when you want to quickly
					check the beginning of a large file. <pre>
						<code>head filename.txt</code>
					</pre> To view a specific number of lines, use the <code>-n</code>
					option: <pre>
						<code>head -n 20 filename.txt</code>
					</pre> This shows the first 20 lines of the file.</li>

				<li><strong><code>tail</code> (View the Last Few Lines
						of a File):</strong> The <code>tail</code> command is the opposite of <code>head</code>;
					it shows the last 10 lines of a file by default. It‚Äôs useful for
					monitoring log files or large datasets where the latest information
					is more relevant. <pre>
						<code>tail filename.txt</code>
					</pre> To view the last few lines or monitor a file in real-time, use: <pre>
						<code>tail -n 20 filename.txt</code>
					</pre> This shows the last 20 lines of the file. <pre>
						<code>tail -f filename.txt</code>
					</pre> The <code>-f</code> option allows you to follow a file in
					real-time (useful for logs).</li>
			</ul>

			<h3>2. Best Tools for Viewing Large Data Files</h3>
			<p>When working with large data files, it's important to use the
				right tool to avoid overwhelming your terminal. Here‚Äôs a breakdown
				of the best tools:</p>
			<ul>
				<li><strong><code>less</code>:</strong> Ideal for viewing large
					files, as it loads the file one page at a time. You can scroll
					through the content and search within the file using <code>/search_term</code>
					and <code>n</code> to go to the next occurrence.</li>
				<li><strong><code>head</code> and <code>tail</code>:</strong>
					These are best when you only need to view the beginning or the end
					of the file, respectively. They are more efficient than loading the
					entire file into the terminal.</li>
				<li><strong><code>cat</code>:</strong> Only recommended for
					small files, as it prints the entire file to the terminal.</li>
			</ul>

			<h3>3. Example Walkthrough: Viewing Large Files</h3>
			<p>Let‚Äôs walk through the process of using these commands to view
				a large file, such as a `.txt` or `.tsv` file.</p>

			<ul>
				<li><strong>View a small file using <code>cat</code>:
				</strong> For a small file, simply use: <pre>
						<code>cat small_file.txt</code>
					</pre> This will display the entire contents of `small_file.txt` at once.
				</li>

				<li><strong>View a large file using <code>less</code>:
				</strong> If the file is large, use: <pre>
						<code>less large_file.txt</code>
					</pre> This will allow you to scroll through the content one page at a
					time, making it much easier to navigate large files.</li>

				<li><strong>View the first few lines of a file using <code>head</code>:
				</strong> If you only want to check the beginning of the file, use: <pre>
						<code>head large_file.txt</code>
					</pre> This will show the first 10 lines by default.</li>

				<li><strong>View the last few lines of a file using <code>tail</code>:
				</strong> To quickly check the end of a file (e.g., for logs or recent data),
					use: <pre>
						<code>tail large_file.txt</code>
					</pre> To monitor the file in real-time (for example, a log file that
					updates constantly), use: <pre>
						<code>tail -f large_file.txt</code>
					</pre></li>
			</ul>

			<h3>4. Activity: Open a `.txt` or `.tsv` File with Each Tool</h3>
			<p>Let's practice opening a file with each tool to better
				understand their usage and functionality.</p>
			<ol>
				<li><strong>Open a small `.txt` file with <code>cat</code>:
				</strong> - Open a terminal and run: <pre>
						<code>cat small_file.txt</code>
					</pre> - Verify that the entire file is printed to the terminal.</li>

				<li><strong>Open a large `.txt` file with <code>less</code>:
				</strong> - Use <code>less</code> to view a large file: <pre>
						<code>less large_file.txt</code>
					</pre> - Scroll through the file using the <code>Space</code> key and
					quit by pressing <code>q</code>.</li>

				<li><strong>Open the first 20 lines of a file with <code>head</code>:
				</strong> - Run the following to view the first 20 lines of a file: <pre>
						<code>head -n 20 large_file.txt</code>
					</pre></li>

				<li><strong>Open the last 20 lines of a file with <code>tail</code>:
				</strong> - View the last 20 lines of the file: <pre>
						<code>tail -n 20 large_file.txt</code>
					</pre></li>

				<li><strong>Monitor a log file with <code>tail
							-f</code>:
				</strong> - If you have a log file, use: <pre>
						<code>tail -f log_file.txt</code>
					</pre> - This will allow you to see updates to the log file in real-time.
				</li>
			</ol>

		
		</section>
		<section id="compressed">
			<h2>üóúÔ∏è Handling Compressed Files</h2>
			<p>Bioinformatics datasets often come as compressed archives. Use
				the following commands to unpack them:</p>

			<table>
				<thead>
					<tr>
						<th>Command</th>
						<th>Description</th>
						<th>Example</th>
					</tr>
				</thead>
				<tbody>
					<tr>
						<td><code>unzip</code></td>
						<td>Extract files from a <code>.zip</code> archive
						</td>
						<td><code>unzip samples.zip</code></td>
					</tr>
					<tr>
						<td><code>tar -xvf</code></td>
						<td>Extract contents from a <code>.tar</code> archive
						</td>
						<td><code>tar -xvf archive.tar</code></td>
					</tr>
					<tr>
						<td><code>tar -xzvf</code></td>
						<td>Extract a <code>.tar.gz</code> (gzip-compressed tar)
						</td>
						<td><code>tar -xzvf genome.tar.gz</code></td>
					</tr>
					<tr>
						<td><code>tar -xjvf</code></td>
						<td>Extract a <code>.tar.bz2</code> (bzip2-compressed tar)
						</td>
						<td><code>tar -xjvf data.tar.bz2</code></td>
					</tr>
					<tr>
						<td><code>gunzip</code></td>
						<td>Unzip a single <code>.gz</code> file
						</td>
						<td><code>gunzip reads.fastq.gz</code></td>
					</tr>
				</tbody>
			</table>

		
		</section>

		<section id="quiz">
			<h2>üìò Linux Terminal Practice: Folder Navigation & File
				Inspection</h2>
			<p>Use the terminal to complete each task. If the command works,
				write down the result. If it returns an error, copy the exact error
				message from your terminal. In some tasks, you‚Äôll be asked what
				command you would use to achieve a certain outcome.</p>
			<p>
				<strong>üìù Instructions:</strong>
			</p>

			<ul>
				<li>1. Write all your answers in a plain text file named <code>yourLastname_activity1.txt</code>.
					Once done, submit the file to: <strong>.....</strong>.
				</li>
				<li>2. Download this file: <a
					href="/bbc2025v1/docs/2025/module1_basic_linux/resources/bio_training.zip"><strong>bio_training.zip</strong></a>.
				</li>
			</ul>


			<h3>üì¶ Task 0: Extract the training archive</h3>
			<pre>
				<code>unzip bio_training.zip</code>
			</pre>
			<p>
				<strong>Q1:</strong> Did the folder
				<code>bio_training/</code>
				get created successfully?
			</p>
			<p>
				<strong>Q2:</strong> If there was an error, what was the exact
				message? What command should be use?
			</p>

			<h3>üîç Task 1: Navigate to a folder</h3>
			<pre>
				<code>cd /bio_training/projectA/data</code>
			</pre>
			<p>
				<strong>Q1:</strong> What are the names of the files in this
				directory? Use
				<code>ls</code>
				to list them.
			</p>
			<p>
				<strong>Q2:</strong> Did the command work? If not, What should
				command be use to go to data folder under projectA?
			</p>

			<h3>üìÑ Task 2: View a file</h3>
			<pre>
				<code>cat exp1.tsv</code>
			</pre>
			<p>
				<strong>Q1:</strong> What is the content of the file? Can you spot
				the gene with the highest expression?
			</p>
			<p>
				<strong>Q2:</strong> Did the command work? If not, what exact error
				message did you see?
			</p>

			<h3>üìÇ Task 3: Count number of files in a directory</h3>
			<pre>
				<code>ls | wc -l</code>
			</pre>
			<p>
				<strong>Q1:</strong> How many items (files and folders) are listed?
			</p>
			<p>
				<strong>Q2:</strong> What command would you use to list the actual
				names instead of just the count?
			</p>

			<h3>üìú Task 4: Check logs</h3>
			<pre>
				<code>tail -n 1 ../results/error.log</code>
			</pre>
			<p>
				<strong>Q1:</strong> What does the last line of the error log say?
			</p>
			<p>
				<strong>Q2:</strong> Did the command work? If not, what exact error
				message did you see?
			</p>

			<h3>üîç Task 5: Search metadata</h3>
			<pre>
				<code>grep FAIL ../../projectB/metadata/samples.tsv</code>
			</pre>
			<p>
				<strong>Q1:</strong> Which samples failed the quality check?
			</p>
			<p>
				<strong>Q2:</strong> What command should be used if we want to
				ignore uppercase/lowercase differences?
			</p>

			<h3>üî¢ Task 6: Count lines in a log file</h3>
			<pre>
				<code>wc -l ../../projectB/logs/pipeline.log</code>
			</pre>
			<p>
				<strong>Q1:</strong> How many lines are in the log file?
			</p>
			<p>
				<strong>Q2:</strong> What command would you use to count the number
				of words instead?
			</p>

			<h3>üìÅ Task 7: Create a new folder and file</h3>
			<pre>
				<code>mkdir analysis && touch analysis/summary.txt</code>
			</pre>
			<p>
				<strong>Q1:</strong> What command would show the full absolute path
				of the new file?
			</p>
			<p>
				<strong>Q2:</strong> What command would you use to confirm that the
				file is empty?
			</p>
		</section>
		-->
		</br> </br> </br>
	</main>
	

</body>
</html>
